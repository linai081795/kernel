diff --git a/drivers/net/phy/rtl8366_smi.c b/drivers/net/phy/rtl8366_smi.c
index 3d98a7e1c..e115b28c3 100644
--- a/drivers/net/phy/rtl8366_smi.c
+++ b/drivers/net/phy/rtl8366_smi.c
@@ -254,9 +254,9 @@ static int __rtl8366_smi_read_reg(struct rtl8366_smi *smi, u32 addr, u32 *data)
 #define MDC_MDIO_WRITE_OP		0x0003
 #define MDC_REALTEK_PHY_ADDR		0x0
 
-static int __rtl8366_mdio_read_reg(struct rtl8366_smi *smi, u32 addr, u32 *data)
+int __rtl8366_mdio_read_reg(struct rtl8366_smi *smi, u32 addr, u32 *data)
 {
-	u32 phy_id = smi->phy_id;
+	u32 phy_id = smi->phy_id ? smi->phy_id : MDC_REALTEK_PHY_ADDR;
 	struct mii_bus *mbus = smi->ext_mbus;
 
 	BUG_ON(in_interrupt());
@@ -293,7 +293,7 @@ static int __rtl8366_mdio_read_reg(struct rtl8366_smi *smi, u32 addr, u32 *data)
 
 static int __rtl8366_mdio_write_reg(struct rtl8366_smi *smi, u32 addr, u32 data)
 {
-	u32 phy_id = smi->phy_id;
+	u32 phy_id = smi->phy_id ? smi->phy_id : MDC_REALTEK_PHY_ADDR;
 	struct mii_bus *mbus = smi->ext_mbus;
 
 	BUG_ON(in_interrupt());
@@ -590,7 +590,7 @@ static int rtl8366_set_pvid(struct rtl8366_smi *smi, unsigned port,
 	return -ENOSPC;
 }
 
-static int rtl8366_smi_enable_vlan(struct rtl8366_smi *smi, int enable)
+int rtl8366_enable_vlan(struct rtl8366_smi *smi, int enable)
 {
 	int err;
 
@@ -607,8 +607,9 @@ static int rtl8366_smi_enable_vlan(struct rtl8366_smi *smi, int enable)
 
 	return err;
 }
+EXPORT_SYMBOL_GPL(rtl8366_enable_vlan);
 
-static int rtl8366_smi_enable_vlan4k(struct rtl8366_smi *smi, int enable)
+static int rtl8366_enable_vlan4k(struct rtl8366_smi *smi, int enable)
 {
 	int err;
 
@@ -628,7 +629,7 @@ static int rtl8366_smi_enable_vlan4k(struct rtl8366_smi *smi, int enable)
 	return 0;
 }
 
-static int rtl8366_smi_enable_all_ports(struct rtl8366_smi *smi, int enable)
+int rtl8366_enable_all_ports(struct rtl8366_smi *smi, int enable)
 {
 	int port;
 	int err;
@@ -641,15 +642,16 @@ static int rtl8366_smi_enable_all_ports(struct rtl8366_smi *smi, int enable)
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(rtl8366_enable_all_ports);
 
-static int rtl8366_smi_reset_vlan(struct rtl8366_smi *smi)
+int rtl8366_reset_vlan(struct rtl8366_smi *smi)
 {
 	struct rtl8366_vlan_mc vlanmc;
 	int err;
 	int i;
 
-	rtl8366_smi_enable_vlan(smi, 0);
-	rtl8366_smi_enable_vlan4k(smi, 0);
+	rtl8366_enable_vlan(smi, 0);
+	rtl8366_enable_vlan4k(smi, 0);
 
 	/* clear VLAN member configurations */
 	vlanmc.vid = 0;
@@ -665,13 +667,14 @@ static int rtl8366_smi_reset_vlan(struct rtl8366_smi *smi)
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(rtl8366_reset_vlan);
 
 static int rtl8366_init_vlan(struct rtl8366_smi *smi)
 {
 	int port;
 	int err;
 
-	err = rtl8366_smi_reset_vlan(smi);
+	err = rtl8366_reset_vlan(smi);
 	if (err)
 		return err;
 
@@ -692,7 +695,7 @@ static int rtl8366_init_vlan(struct rtl8366_smi *smi)
 			return err;
 	}
 
-	return rtl8366_smi_enable_vlan(smi, 1);
+	return rtl8366_enable_vlan(smi, 1);
 }
 
 #ifdef CONFIG_RTL8366_SMI_DEBUG_FS
@@ -941,8 +944,14 @@ static void rtl8366_debugfs_init(struct rtl8366_smi *smi)
 	}
 	root = smi->debugfs_root;
 
-	debugfs_create_x16("reg", S_IRUGO | S_IWUSR, root,
+	node = debugfs_create_x16("reg", S_IRUGO | S_IWUSR, root,
 				  &smi->dbg_reg);
+	if (!node) {
+		dev_err(smi->parent, "Creating debugfs file '%s' failed\n",
+			"reg");
+		return;
+	}
+
 	node = debugfs_create_file("val", S_IRUGO | S_IWUSR, root, smi,
 				   &fops_rtl8366_regs);
 	if (!node) {
@@ -959,8 +968,13 @@ static void rtl8366_debugfs_init(struct rtl8366_smi *smi)
 		return;
 	}
 
-	debugfs_create_u8("vlan_4k_page", S_IRUGO | S_IWUSR, root,
+	node = debugfs_create_u8("vlan_4k_page", S_IRUGO | S_IWUSR, root,
 				  &smi->dbg_vlan_4k_page);
+	if (!node) {
+		dev_err(smi->parent, "Creating debugfs file '%s' failed\n",
+			"vlan_4k_page");
+		return;
+	}
 
 	node = debugfs_create_file("vlan_4k", S_IRUSR, root, smi,
 				   &fops_rtl8366_vlan_4k);
@@ -1059,15 +1073,15 @@ int rtl8366_sw_reset_switch(struct switch_dev *dev)
 	if (err)
 		return err;
 
-	err = rtl8366_smi_reset_vlan(smi);
+	err = rtl8366_reset_vlan(smi);
 	if (err)
 		return err;
 
-	err = rtl8366_smi_enable_vlan(smi, 1);
+	err = rtl8366_enable_vlan(smi, 1);
 	if (err)
 		return err;
 
-	return rtl8366_smi_enable_all_ports(smi, 1);
+	return rtl8366_enable_all_ports(smi, 1);
 }
 EXPORT_SYMBOL_GPL(rtl8366_sw_reset_switch);
 
@@ -1329,9 +1343,9 @@ int rtl8366_sw_set_vlan_enable(struct switch_dev *dev,
 		return -EINVAL;
 
 	if (attr->ofs == 1)
-		err = rtl8366_smi_enable_vlan(smi, val->value.i);
+		err = rtl8366_enable_vlan(smi, val->value.i);
 	else
-		err = rtl8366_smi_enable_vlan4k(smi, val->value.i);
+		err = rtl8366_enable_vlan4k(smi, val->value.i);
 
 	return err;
 }
@@ -1480,7 +1494,7 @@ int rtl8366_smi_init(struct rtl8366_smi *smi)
 		goto err_free_sck;
 	}
 
-	err = rtl8366_smi_enable_all_ports(smi, 1);
+	err = rtl8366_enable_all_ports(smi, 1);
 	if (err)
 		goto err_free_sck;
 
@@ -1516,7 +1530,7 @@ static void rtl8366_smi_reset(struct rtl8366_smi *smi, bool active)
 		reset_control_deassert(smi->reset);
 }
 
-static int rtl8366_smi_probe_of(struct platform_device *pdev, struct rtl8366_smi *smi)
+int rtl8366_smi_probe_of(struct platform_device *pdev, struct rtl8366_smi *smi)
 {
 	int sck = of_get_named_gpio(pdev->dev.of_node, "gpio-sck", 0);
 	int sda = of_get_named_gpio(pdev->dev.of_node, "gpio-sda", 0);
@@ -1536,9 +1550,6 @@ static int rtl8366_smi_probe_of(struct platform_device *pdev, struct rtl8366_smi
 		goto try_gpio;
 	}
 
-	if (of_property_read_u32(np, "phy-id", &smi->phy_id))
-		smi->phy_id = MDC_REALTEK_PHY_ADDR;
-
 	return 0;
 
 try_gpio:
@@ -1566,7 +1577,7 @@ static inline int rtl8366_smi_probe_of(struct platform_device *pdev, struct rtl8
 }
 #endif
 
-static int rtl8366_smi_probe_plat(struct platform_device *pdev, struct rtl8366_smi *smi)
+int rtl8366_smi_probe_plat(struct platform_device *pdev, struct rtl8366_smi *smi)
 {
 	struct rtl8366_platform_data *pdata = pdev->dev.platform_data;
 
@@ -1578,7 +1589,6 @@ static int rtl8366_smi_probe_plat(struct platform_device *pdev, struct rtl8366_s
 	smi->gpio_sda = pdata->gpio_sda;
 	smi->gpio_sck = pdata->gpio_sck;
 	smi->hw_reset = pdata->hw_reset;
-	smi->phy_id = MDC_REALTEK_PHY_ADDR;
 
 	return 0;
 }
diff --git a/drivers/net/phy/rtl8366_smi.h b/drivers/net/phy/rtl8366_smi.h
index 2608240bb..7c7cb853d 100644
--- a/drivers/net/phy/rtl8366_smi.h
+++ b/drivers/net/phy/rtl8366_smi.h
@@ -23,18 +23,6 @@ struct dentry;
 struct inode;
 struct file;
 
-typedef enum rtl8367b_chip_e {
-	RTL8367B_CHIP_UNKNOWN,
- /* Family B */
-	RTL8367B_CHIP_RTL8367RB,
-	RTL8367B_CHIP_RTL8367R_VB, /* chip with exception in extif assignment */
-/* Family C */
-	RTL8367B_CHIP_RTL8367RB_VB,
-	RTL8367B_CHIP_RTL8367S,
-/* Family D */
-	RTL8367B_CHIP_RTL8367S_VB /* chip with exception in extif assignment */
-} rtl8367b_chip_t;
-
 struct rtl8366_mib_counter {
 	unsigned	base;
 	unsigned	offset;
@@ -75,10 +63,8 @@ struct rtl8366_smi {
 	u16			dbg_reg;
 	u8			dbg_vlan_4k_page;
 #endif
-	u32			phy_id;
-	rtl8367b_chip_t		rtl8367b_chip;
 	struct mii_bus		*ext_mbus;
-	struct rtl8366_vlan_mc *emu_vlanmc;
+	u32			phy_id;
 };
 
 struct rtl8366_vlan_mc {
@@ -130,6 +116,10 @@ int rtl8366_smi_write_reg_noack(struct rtl8366_smi *smi, u32 addr, u32 data);
 int rtl8366_smi_read_reg(struct rtl8366_smi *smi, u32 addr, u32 *data);
 int rtl8366_smi_rmwr(struct rtl8366_smi *smi, u32 addr, u32 mask, u32 data);
 
+int rtl8366_reset_vlan(struct rtl8366_smi *smi);
+int rtl8366_enable_vlan(struct rtl8366_smi *smi, int enable);
+int rtl8366_enable_all_ports(struct rtl8366_smi *smi, int enable);
+
 #ifdef CONFIG_RTL8366_SMI_DEBUG_FS
 int rtl8366_debugfs_open(struct inode *inode, struct file *file);
 #endif
diff --git a/drivers/net/phy/rtl8367b.c b/drivers/net/phy/rtl8367b.c
index 497bd08c8..ef504a1d9 100644
--- a/drivers/net/phy/rtl8367b.c
+++ b/drivers/net/phy/rtl8367b.c
@@ -1,7 +1,5 @@
 /*
- * Platform driver for Realtek RTL8367B family chips, i.e. RTL8367RB and RTL8367R-VB
- * extended with support for RTL8367C family chips, i.e. RTL8367RB-VB and RTL8367S
- * extended with support for RTL8367D family chips, i.e. RTL8367S-VB
+ * Platform driver for the Realtek RTL8367R-VB ethernet switches
  *
  * Copyright (C) 2012 Gabor Juhos <juhosg@openwrt.org>
  *
@@ -216,6 +214,87 @@
 #define RTL8367B_RTL_MAGIC_ID_REG		0x13c2
 #define   RTL8367B_RTL_MAGIC_ID_VAL		0x0249
 
+#define RTL8367S_EXT_TXC_DLY_REG		0x13f9
+#define   RTL8367S_EXT1_GMII_TX_DELAY_SHIFT	12
+#define   RTL8367S_EXT0_GMII_TX_DELAY_SHIFT	9
+#define   RTL8367S_EXT_GMII_TX_DELAY_MASK	GENMASK(2,0)
+
+#define RTL8367S_SDS_MISC				0x1d11
+#define   RTL8367S_CFG_SGMII_RXFC		BIT(14)
+#define   RTL8367S_CFG_SGMII_TXFC		BIT(13)
+#define   RTL8367S_CFG_MAC8_SEL_HSGMII_SHIFT	11
+#define   RTL8367S_CFG_MAC8_SEL_HSGMII_MASK	BIT(11)
+#define   RTL8367S_CFG_SGMII_FDUP		BIT(10)
+#define   RTL8367S_CFG_SGMII_LINK		BIT(9)
+#define   RTL8367S_CFG_SGMII_SPD_SHIFT		7
+#define   RTL8367S_CFG_SGMII_SPD_MASK		GENMASK(8,7)
+#define   RTL8367S_CFG_MAC8_SEL_SGMII		BIT(6)
+
+//led 
+#define    RTL8367S_REG_LED_ACTIVE_LOW_CFG0    0x1b0e
+#define    RTL8367S_LED_ACTIVE_LOW_CFG0_DUMMY_15_OFFSET    15
+#define    RTL8367S_LED_ACTIVE_LOW_CFG0_DUMMY_15_MASK    0x8000
+#define    RTL8367S_PORT3_LED_ACTIVE_LOW_OFFSET    12
+#define    RTL8367S_PORT3_LED_ACTIVE_LOW_MASK    0x7000
+#define    RTL8367S_LED_ACTIVE_LOW_CFG0_DUMMY_11_OFFSET    11
+#define    RTL8367S_LED_ACTIVE_LOW_CFG0_DUMMY_11_MASK    0x800
+#define    RTL8367S_PORT2_LED_ACTIVE_LOW_OFFSET    8
+#define    RTL8367S_PORT2_LED_ACTIVE_LOW_MASK    0x700
+#define    RTL8367S_DUMMY_7_OFFSET    7
+#define    RTL8367S_DUMMY_7_MASK    0x80
+#define    RTL8367S_PORT1_LED_ACTIVE_LOW_OFFSET    4
+#define    RTL8367S_PORT1_LED_ACTIVE_LOW_MASK    0x70
+#define    RTL8367S_DUMMY_3_OFFSET    3
+#define    RTL8367S_DUMMY_3_MASK    0x8
+#define    RTL8367S_PORT0_LED_ACTIVE_LOW_OFFSET    0
+#define    RTL8367S_PORT0_LED_ACTIVE_LOW_MASK    0x7
+
+#define    RTL8367S_REG_LED_ACTIVE_LOW_CFG1    0x1b0f
+#define    RTL8367S_LED_ACTIVE_LOW_CFG1_DUMMY_15_OFFSET    15
+#define    RTL8367S_LED_ACTIVE_LOW_CFG1_DUMMY_15_MASK    0x8000
+#define    RTL8367S_PORT7_LED_ACTIVE_LOW_OFFSET    12
+#define    RTL8367S_PORT7_LED_ACTIVE_LOW_MASK    0x7000
+#define    RTL8367S_LED_ACTIVE_LOW_CFG1_DUMMY_11_OFFSET    11
+#define    RTL8367S_LED_ACTIVE_LOW_CFG1_DUMMY_11_MASK    0x800
+#define    RTL8367S_PORT6_LED_ACTIVE_LOW_OFFSET    8
+#define    RTL8367S_PORT6_LED_ACTIVE_LOW_MASK    0x700
+#define    RTL8367S_DUMMY_1b0f_b_OFFSET    7
+#define    RTL8367S_DUMMY_1b0f_b_MASK    0x80
+#define    RTL8367S_PORT5_LED_ACTIVE_LOW_OFFSET    4
+#define    RTL8367S_PORT5_LED_ACTIVE_LOW_MASK    0x70
+#define    RTL8367S_DUMMY_1b0f_a_OFFSET    3
+#define    RTL8367S_DUMMY_1b0f_a_MASK    0x8
+#define    RTL8367S_PORT4_LED_ACTIVE_LOW_OFFSET    0
+#define    RTL8367S_PORT4_LED_ACTIVE_LOW_MASK    0x7
+
+#define    RTL8367S_REG_LED_ACTIVE_LOW_CFG2    0x1b10
+#define    RTL8367S_DUMMY_1b10_b_OFFSET    7
+#define    RTL8367S_DUMMY_1b10_b_MASK    0xFF80
+#define    RTL8367S_PORT9_LED_ACTIVE_LOW_OFFSET    4
+#define    RTL8367S_PORT9_LED_ACTIVE_LOW_MASK    0x70
+#define    RTL8367S_DUMMY_1b10_a_OFFSET    3
+#define    RTL8367S_DUMMY_1b10_a_MASK    0x8
+#define    RTL8367S_PORT8_LED_ACTIVE_LOW_OFFSET    0
+#define    RTL8367S_PORT8_LED_ACTIVE_LOW_MASK    0x7
+
+#define RTL8367S_PORT_0                  BIT(0)
+#define RTL8367S_PORT_1                  BIT(1)
+#define RTL8367S_PORT_2                  BIT(2)
+#define RTL8367S_PORT_3                  BIT(3)
+#define RTL8367S_PORT_4                  BIT(4)
+#define RTL8367S_PORT_5                  BIT(5)
+#define RTL8367S_PORT_6                  BIT(6)
+#define RTL8367S_PORT_7                  BIT(7)
+#define RTL8367S_PORT_E1                 BIT(8)  /* external port 1 */
+#define RTL8367S_PORT_E0                 BIT(9)  /* external port 0 */
+
+#define RTL8367S_PORTS_ALL                                       \
+        (RTL8367S_PORT_0 | RTL8367S_PORT_1 | RTL8367S_PORT_2 |     \
+         RTL8367S_PORT_3 | RTL8367S_PORT_4 | RTL8367S_PORT_5 |     \
+         RTL8367S_PORT_6 | RTL8367S_PORT_7 | RTL8367S_PORT_E1 |    \
+         RTL8367S_PORT_E0)
+//-------------------RTL8367S--------------------------------------
+
 #define RTL8367B_IA_CTRL_REG			0x1f00
 #define   RTL8367B_IA_CTRL_RW(_x)		((_x) << 1)
 #define   RTL8367B_IA_CTRL_RW_READ		RTL8367B_IA_CTRL_RW(0)
@@ -233,9 +312,18 @@
 
 #define RTL8367B_INTERNAL_PHY_REG(_a, _r)	(0x2000 + 32 * (_a) + (_r))
 
+/* SerDes indirect access */
+#define RTL8367S_SDS_INDACS_CMD_REG		0x6600
+#define RTL8367S_SDS_CMD			BIT(7)
+#define RTL8367S_SDS_RWOP			BIT(6)
+#define RTL8367S_SDS_INDACS_ADDR_REG		0x6601
+#define RTL8367S_SDS_INDACS_DATA_REG		0x6602
+
 #define RTL8367B_NUM_MIB_COUNTERS	58
 
+#define RTL8367S_PHY_ADDR		29
 #define RTL8367B_CPU_PORT_NUM		5
+#define RTL8367S_CPU_PORT_NUM		7
 #define RTL8367B_NUM_PORTS		8
 #define RTL8367B_NUM_VLANS		32
 #define RTL8367B_NUM_VIDS		4096
@@ -258,48 +346,19 @@
 
 #define RTL8367B_PORTS_ALL_BUT_CPU				\
 	(RTL8367B_PORT_0 | RTL8367B_PORT_1 | RTL8367B_PORT_2 |	\
-	 RTL8367B_PORT_3 | RTL8367B_PORT_4 | RTL8367B_PORT_E1 |	\
-	 RTL8367B_PORT_E2)
+	 RTL8367B_PORT_3 | RTL8367B_PORT_4 | RTL8367B_PORT_E0 |	\
+	 RTL8367B_PORT_E1)
 
 struct rtl8367b_initval {
 	u16 reg;
 	u16 val;
 };
 
+u32 rtl_device_id;
+
 #define RTL8367B_MIB_RXB_ID		0	/* IfInOctets */
 #define RTL8367B_MIB_TXB_ID		28	/* IfOutOctets */
 
-#define RTL8367D_PORT_STATUS_REG(_p)		(0x12d0 + (_p))
-
-#define RTL8367D_PORT_STATUS_SPEED1_MASK	0x3000
-#define RTL8367D_PORT_STATUS_SPEED1_SHIFT	10 /*12-2*/
-
-#define RTL8367D_REG_MAC0_FORCE_SELECT		0x12c0
-#define RTL8367D_REG_MAC0_FORCE_SELECT_EN	0x12c8
-
-#define RTL8367D_VLAN_PVID_CTRL_REG(_p)		(0x0700 + (_p))
-#define RTL8367D_VLAN_PVID_CTRL_MASK		0xfff
-#define RTL8367D_VLAN_PVID_CTRL_SHIFT(_p)	0
-
-#define RTL8367D_FIDMAX			3
-#define RTL8367D_FID_MASK		3
-#define RTL8367D_TA_VLAN1_FID_SHIFT	0
-#define RTL8367D_TA_VLAN1_FID_MASK	RTL8367D_FID_MASK
-
-#define RTL8367D_VID_MASK		0xfff
-#define RTL8367D_TA_VLAN_VID_MASK	RTL8367D_VID_MASK
-
-#define RTL8367D_REG_EXT_TXC_DLY		0x13f9
-#define RTL8367D_EXT1_RGMII_TX_DLY_MASK		0x38
-
-#define RTL8367D_REG_TOP_CON0			0x1d70
-#define   RTL8367D_MAC7_SEL_EXT1_MASK		0x2000
-#define   RTL8367D_MAC4_SEL_EXT1_MASK		0x1000
-
-#define RTL8367D_REG_SDS1_MISC0			0x1d78
-#define   RTL8367D_SDS1_MODE_MASK		0x1f
-#define   RTL8367D_PORT_SDS_MODE_DISABLE		0x1f
-
 static struct rtl8366_mib_counter
 rtl8367b_mib_counters[RTL8367B_NUM_MIB_COUNTERS] = {
 	{0,   0, 4, "ifInOctets"			},
@@ -385,7 +444,220 @@ rtl8367b_mib_counters[RTL8367B_NUM_MIB_COUNTERS] = {
 			return err;					\
 	} while (0)
 
-static const struct rtl8367b_initval rtl8367b_initvals[] = {
+static const struct rtl8367b_initval rtl8367r_vb_initvals_0[] = {
+	{0x1B03, 0x0876}, {0x1200, 0x7FC4}, {0x0301, 0x0026}, {0x1722, 0x0E14},
+	{0x205F, 0x0002}, {0x2059, 0x1A00}, {0x205F, 0x0000}, {0x207F, 0x0002},
+	{0x2077, 0x0000}, {0x2078, 0x0000}, {0x2079, 0x0000}, {0x207A, 0x0000},
+	{0x207B, 0x0000}, {0x207F, 0x0000}, {0x205F, 0x0002}, {0x2053, 0x0000},
+	{0x2054, 0x0000}, {0x2055, 0x0000}, {0x2056, 0x0000}, {0x2057, 0x0000},
+	{0x205F, 0x0000}, {0x12A4, 0x110A}, {0x12A6, 0x150A}, {0x13F1, 0x0013},
+	{0x13F4, 0x0010}, {0x13F5, 0x0000}, {0x0018, 0x0F00}, {0x0038, 0x0F00},
+	{0x0058, 0x0F00}, {0x0078, 0x0F00}, {0x0098, 0x0F00}, {0x12B6, 0x0C02},
+	{0x12B7, 0x030F}, {0x12B8, 0x11FF}, {0x12BC, 0x0004}, {0x1362, 0x0115},
+	{0x1363, 0x0002}, {0x1363, 0x0000}, {0x133F, 0x0030}, {0x133E, 0x000E},
+	{0x221F, 0x0007}, {0x221E, 0x002D}, {0x2218, 0xF030}, {0x221F, 0x0007},
+	{0x221E, 0x0023}, {0x2216, 0x0005}, {0x2215, 0x00B9}, {0x2219, 0x0044},
+	{0x2215, 0x00BA}, {0x2219, 0x0020}, {0x2215, 0x00BB}, {0x2219, 0x00C1},
+	{0x2215, 0x0148}, {0x2219, 0x0096}, {0x2215, 0x016E}, {0x2219, 0x0026},
+	{0x2216, 0x0000}, {0x2216, 0x0000}, {0x221E, 0x002D}, {0x2218, 0xF010},
+	{0x221F, 0x0007}, {0x221E, 0x0020}, {0x2215, 0x0D00}, {0x221F, 0x0000},
+	{0x221F, 0x0000}, {0x2217, 0x2160}, {0x221F, 0x0001}, {0x2210, 0xF25E},
+	{0x221F, 0x0007}, {0x221E, 0x0042}, {0x2215, 0x0F00}, {0x2215, 0x0F00},
+	{0x2216, 0x7408}, {0x2215, 0x0E00}, {0x2215, 0x0F00}, {0x2215, 0x0F01},
+	{0x2216, 0x4000}, {0x2215, 0x0E01}, {0x2215, 0x0F01}, {0x2215, 0x0F02},
+	{0x2216, 0x9400}, {0x2215, 0x0E02}, {0x2215, 0x0F02}, {0x2215, 0x0F03},
+	{0x2216, 0x7408}, {0x2215, 0x0E03}, {0x2215, 0x0F03}, {0x2215, 0x0F04},
+	{0x2216, 0x4008}, {0x2215, 0x0E04}, {0x2215, 0x0F04}, {0x2215, 0x0F05},
+	{0x2216, 0x9400}, {0x2215, 0x0E05}, {0x2215, 0x0F05}, {0x2215, 0x0F06},
+	{0x2216, 0x0803}, {0x2215, 0x0E06}, {0x2215, 0x0F06}, {0x2215, 0x0D00},
+	{0x2215, 0x0100}, {0x221F, 0x0001}, {0x2210, 0xF05E}, {0x221F, 0x0000},
+	{0x2217, 0x2100}, {0x221F, 0x0000}, {0x220D, 0x0003}, {0x220E, 0x0015},
+	{0x220D, 0x4003}, {0x220E, 0x0006}, {0x221F, 0x0000}, {0x2200, 0x1340},
+	{0x133F, 0x0010}, {0x12A0, 0x0058}, {0x12A1, 0x0058}, {0x133E, 0x000E},
+	{0x133F, 0x0030}, {0x221F, 0x0000}, {0x2210, 0x0166}, {0x221F, 0x0000},
+	{0x133E, 0x000E}, {0x133F, 0x0010}, {0x133F, 0x0030}, {0x133E, 0x000E},
+	{0x221F, 0x0005}, {0x2205, 0xFFF6}, {0x2206, 0x0080}, {0x2205, 0x8B6E},
+	{0x2206, 0x0000}, {0x220F, 0x0100}, {0x2205, 0x8000}, {0x2206, 0x0280},
+	{0x2206, 0x28F7}, {0x2206, 0x00E0}, {0x2206, 0xFFF7}, {0x2206, 0xA080},
+	{0x2206, 0x02AE}, {0x2206, 0xF602}, {0x2206, 0x0153}, {0x2206, 0x0201},
+	{0x2206, 0x6602}, {0x2206, 0x80B9}, {0x2206, 0xE08B}, {0x2206, 0x8CE1},
+	{0x2206, 0x8B8D}, {0x2206, 0x1E01}, {0x2206, 0xE18B}, {0x2206, 0x8E1E},
+	{0x2206, 0x01A0}, {0x2206, 0x00E7}, {0x2206, 0xAEDB}, {0x2206, 0xEEE0},
+	{0x2206, 0x120E}, {0x2206, 0xEEE0}, {0x2206, 0x1300}, {0x2206, 0xEEE0},
+	{0x2206, 0x2001}, {0x2206, 0xEEE0}, {0x2206, 0x2166}, {0x2206, 0xEEE0},
+	{0x2206, 0xC463}, {0x2206, 0xEEE0}, {0x2206, 0xC5E8}, {0x2206, 0xEEE0},
+	{0x2206, 0xC699}, {0x2206, 0xEEE0}, {0x2206, 0xC7C2}, {0x2206, 0xEEE0},
+	{0x2206, 0xC801}, {0x2206, 0xEEE0}, {0x2206, 0xC913}, {0x2206, 0xEEE0},
+	{0x2206, 0xCA30}, {0x2206, 0xEEE0}, {0x2206, 0xCB3E}, {0x2206, 0xEEE0},
+	{0x2206, 0xDCE1}, {0x2206, 0xEEE0}, {0x2206, 0xDD00}, {0x2206, 0xEEE2},
+	{0x2206, 0x0001}, {0x2206, 0xEEE2}, {0x2206, 0x0100}, {0x2206, 0xEEE4},
+	{0x2206, 0x8860}, {0x2206, 0xEEE4}, {0x2206, 0x8902}, {0x2206, 0xEEE4},
+	{0x2206, 0x8C00}, {0x2206, 0xEEE4}, {0x2206, 0x8D30}, {0x2206, 0xEEEA},
+	{0x2206, 0x1480}, {0x2206, 0xEEEA}, {0x2206, 0x1503}, {0x2206, 0xEEEA},
+	{0x2206, 0xC600}, {0x2206, 0xEEEA}, {0x2206, 0xC706}, {0x2206, 0xEE85},
+	{0x2206, 0xEE00}, {0x2206, 0xEE85}, {0x2206, 0xEF00}, {0x2206, 0xEE8B},
+	{0x2206, 0x6750}, {0x2206, 0xEE8B}, {0x2206, 0x6632}, {0x2206, 0xEE8A},
+	{0x2206, 0xD448}, {0x2206, 0xEE8A}, {0x2206, 0xD548}, {0x2206, 0xEE8A},
+	{0x2206, 0xD649}, {0x2206, 0xEE8A}, {0x2206, 0xD7F8}, {0x2206, 0xEE8B},
+	{0x2206, 0x85E2}, {0x2206, 0xEE8B}, {0x2206, 0x8700}, {0x2206, 0xEEFF},
+	{0x2206, 0xF600}, {0x2206, 0xEEFF}, {0x2206, 0xF7FC}, {0x2206, 0x04F8},
+	{0x2206, 0xE08B}, {0x2206, 0x8EAD}, {0x2206, 0x2023}, {0x2206, 0xF620},
+	{0x2206, 0xE48B}, {0x2206, 0x8E02}, {0x2206, 0x2877}, {0x2206, 0x0225},
+	{0x2206, 0xC702}, {0x2206, 0x26A1}, {0x2206, 0x0281}, {0x2206, 0xB302},
+	{0x2206, 0x8496}, {0x2206, 0x0202}, {0x2206, 0xA102}, {0x2206, 0x27F1},
+	{0x2206, 0x0228}, {0x2206, 0xF902}, {0x2206, 0x2AA0}, {0x2206, 0x0282},
+	{0x2206, 0xB8E0}, {0x2206, 0x8B8E}, {0x2206, 0xAD21}, {0x2206, 0x08F6},
+	{0x2206, 0x21E4}, {0x2206, 0x8B8E}, {0x2206, 0x0202}, {0x2206, 0x80E0},
+	{0x2206, 0x8B8E}, {0x2206, 0xAD22}, {0x2206, 0x05F6}, {0x2206, 0x22E4},
+	{0x2206, 0x8B8E}, {0x2206, 0xE08B}, {0x2206, 0x8EAD}, {0x2206, 0x2305},
+	{0x2206, 0xF623}, {0x2206, 0xE48B}, {0x2206, 0x8EE0}, {0x2206, 0x8B8E},
+	{0x2206, 0xAD24}, {0x2206, 0x08F6}, {0x2206, 0x24E4}, {0x2206, 0x8B8E},
+	{0x2206, 0x0227}, {0x2206, 0x6AE0}, {0x2206, 0x8B8E}, {0x2206, 0xAD25},
+	{0x2206, 0x05F6}, {0x2206, 0x25E4}, {0x2206, 0x8B8E}, {0x2206, 0xE08B},
+	{0x2206, 0x8EAD}, {0x2206, 0x260B}, {0x2206, 0xF626}, {0x2206, 0xE48B},
+	{0x2206, 0x8E02}, {0x2206, 0x830D}, {0x2206, 0x021D}, {0x2206, 0x6BE0},
+	{0x2206, 0x8B8E}, {0x2206, 0xAD27}, {0x2206, 0x05F6}, {0x2206, 0x27E4},
+	{0x2206, 0x8B8E}, {0x2206, 0x0281}, {0x2206, 0x4402}, {0x2206, 0x045C},
+	{0x2206, 0xFC04}, {0x2206, 0xF8E0}, {0x2206, 0x8B83}, {0x2206, 0xAD23},
+	{0x2206, 0x30E0}, {0x2206, 0xE022}, {0x2206, 0xE1E0}, {0x2206, 0x2359},
+	{0x2206, 0x02E0}, {0x2206, 0x85EF}, {0x2206, 0xE585}, {0x2206, 0xEFAC},
+	{0x2206, 0x2907}, {0x2206, 0x1F01}, {0x2206, 0x9E51}, {0x2206, 0xAD29},
+	{0x2206, 0x20E0}, {0x2206, 0x8B83}, {0x2206, 0xAD21}, {0x2206, 0x06E1},
+	{0x2206, 0x8B84}, {0x2206, 0xAD28}, {0x2206, 0x42E0}, {0x2206, 0x8B85},
+	{0x2206, 0xAD21}, {0x2206, 0x06E1}, {0x2206, 0x8B84}, {0x2206, 0xAD29},
+	{0x2206, 0x36BF}, {0x2206, 0x34BF}, {0x2206, 0x022C}, {0x2206, 0x31AE},
+	{0x2206, 0x2EE0}, {0x2206, 0x8B83}, {0x2206, 0xAD21}, {0x2206, 0x10E0},
+	{0x2206, 0x8B84}, {0x2206, 0xF620}, {0x2206, 0xE48B}, {0x2206, 0x84EE},
+	{0x2206, 0x8ADA}, {0x2206, 0x00EE}, {0x2206, 0x8ADB}, {0x2206, 0x00E0},
+	{0x2206, 0x8B85}, {0x2206, 0xAD21}, {0x2206, 0x0CE0}, {0x2206, 0x8B84},
+	{0x2206, 0xF621}, {0x2206, 0xE48B}, {0x2206, 0x84EE}, {0x2206, 0x8B72},
+	{0x2206, 0xFFBF}, {0x2206, 0x34C2}, {0x2206, 0x022C}, {0x2206, 0x31FC},
+	{0x2206, 0x04F8}, {0x2206, 0xFAEF}, {0x2206, 0x69E0}, {0x2206, 0x8B85},
+	{0x2206, 0xAD21}, {0x2206, 0x42E0}, {0x2206, 0xE022}, {0x2206, 0xE1E0},
+	{0x2206, 0x2358}, {0x2206, 0xC059}, {0x2206, 0x021E}, {0x2206, 0x01E1},
+	{0x2206, 0x8B72}, {0x2206, 0x1F10}, {0x2206, 0x9E2F}, {0x2206, 0xE48B},
+	{0x2206, 0x72AD}, {0x2206, 0x2123}, {0x2206, 0xE18B}, {0x2206, 0x84F7},
+	{0x2206, 0x29E5}, {0x2206, 0x8B84}, {0x2206, 0xAC27}, {0x2206, 0x10AC},
+	{0x2206, 0x2605}, {0x2206, 0x0205}, {0x2206, 0x23AE}, {0x2206, 0x1602},
+	{0x2206, 0x0535}, {0x2206, 0x0282}, {0x2206, 0x30AE}, {0x2206, 0x0E02},
+	{0x2206, 0x056A}, {0x2206, 0x0282}, {0x2206, 0x75AE}, {0x2206, 0x0602},
+	{0x2206, 0x04DC}, {0x2206, 0x0282}, {0x2206, 0x04EF}, {0x2206, 0x96FE},
+	{0x2206, 0xFC04}, {0x2206, 0xF8F9}, {0x2206, 0xE08B}, {0x2206, 0x87AD},
+	{0x2206, 0x2321}, {0x2206, 0xE0EA}, {0x2206, 0x14E1}, {0x2206, 0xEA15},
+	{0x2206, 0xAD26}, {0x2206, 0x18F6}, {0x2206, 0x27E4}, {0x2206, 0xEA14},
+	{0x2206, 0xE5EA}, {0x2206, 0x15F6}, {0x2206, 0x26E4}, {0x2206, 0xEA14},
+	{0x2206, 0xE5EA}, {0x2206, 0x15F7}, {0x2206, 0x27E4}, {0x2206, 0xEA14},
+	{0x2206, 0xE5EA}, {0x2206, 0x15FD}, {0x2206, 0xFC04}, {0x2206, 0xF8F9},
+	{0x2206, 0xE08B}, {0x2206, 0x87AD}, {0x2206, 0x233A}, {0x2206, 0xAD22},
+	{0x2206, 0x37E0}, {0x2206, 0xE020}, {0x2206, 0xE1E0}, {0x2206, 0x21AC},
+	{0x2206, 0x212E}, {0x2206, 0xE0EA}, {0x2206, 0x14E1}, {0x2206, 0xEA15},
+	{0x2206, 0xF627}, {0x2206, 0xE4EA}, {0x2206, 0x14E5}, {0x2206, 0xEA15},
+	{0x2206, 0xE2EA}, {0x2206, 0x12E3}, {0x2206, 0xEA13}, {0x2206, 0x5A8F},
+	{0x2206, 0x6A20}, {0x2206, 0xE6EA}, {0x2206, 0x12E7}, {0x2206, 0xEA13},
+	{0x2206, 0xF726}, {0x2206, 0xE4EA}, {0x2206, 0x14E5}, {0x2206, 0xEA15},
+	{0x2206, 0xF727}, {0x2206, 0xE4EA}, {0x2206, 0x14E5}, {0x2206, 0xEA15},
+	{0x2206, 0xFDFC}, {0x2206, 0x04F8}, {0x2206, 0xF9E0}, {0x2206, 0x8B87},
+	{0x2206, 0xAD23}, {0x2206, 0x38AD}, {0x2206, 0x2135}, {0x2206, 0xE0E0},
+	{0x2206, 0x20E1}, {0x2206, 0xE021}, {0x2206, 0xAC21}, {0x2206, 0x2CE0},
+	{0x2206, 0xEA14}, {0x2206, 0xE1EA}, {0x2206, 0x15F6}, {0x2206, 0x27E4},
+	{0x2206, 0xEA14}, {0x2206, 0xE5EA}, {0x2206, 0x15E2}, {0x2206, 0xEA12},
+	{0x2206, 0xE3EA}, {0x2206, 0x135A}, {0x2206, 0x8FE6}, {0x2206, 0xEA12},
+	{0x2206, 0xE7EA}, {0x2206, 0x13F7}, {0x2206, 0x26E4}, {0x2206, 0xEA14},
+	{0x2206, 0xE5EA}, {0x2206, 0x15F7}, {0x2206, 0x27E4}, {0x2206, 0xEA14},
+	{0x2206, 0xE5EA}, {0x2206, 0x15FD}, {0x2206, 0xFC04}, {0x2206, 0xF8FA},
+	{0x2206, 0xEF69}, {0x2206, 0xE08B}, {0x2206, 0x86AD}, {0x2206, 0x2146},
+	{0x2206, 0xE0E0}, {0x2206, 0x22E1}, {0x2206, 0xE023}, {0x2206, 0x58C0},
+	{0x2206, 0x5902}, {0x2206, 0x1E01}, {0x2206, 0xE18B}, {0x2206, 0x651F},
+	{0x2206, 0x109E}, {0x2206, 0x33E4}, {0x2206, 0x8B65}, {0x2206, 0xAD21},
+	{0x2206, 0x22AD}, {0x2206, 0x272A}, {0x2206, 0xD400}, {0x2206, 0x01BF},
+	{0x2206, 0x34F2}, {0x2206, 0x022C}, {0x2206, 0xA2BF}, {0x2206, 0x34F5},
+	{0x2206, 0x022C}, {0x2206, 0xE0E0}, {0x2206, 0x8B67}, {0x2206, 0x1B10},
+	{0x2206, 0xAA14}, {0x2206, 0xE18B}, {0x2206, 0x660D}, {0x2206, 0x1459},
+	{0x2206, 0x0FAE}, {0x2206, 0x05E1}, {0x2206, 0x8B66}, {0x2206, 0x590F},
+	{0x2206, 0xBF85}, {0x2206, 0x6102}, {0x2206, 0x2CA2}, {0x2206, 0xEF96},
+	{0x2206, 0xFEFC}, {0x2206, 0x04F8}, {0x2206, 0xF9FA}, {0x2206, 0xFBEF},
+	{0x2206, 0x79E2}, {0x2206, 0x8AD2}, {0x2206, 0xAC19}, {0x2206, 0x2DE0},
+	{0x2206, 0xE036}, {0x2206, 0xE1E0}, {0x2206, 0x37EF}, {0x2206, 0x311F},
+	{0x2206, 0x325B}, {0x2206, 0x019E}, {0x2206, 0x1F7A}, {0x2206, 0x0159},
+	{0x2206, 0x019F}, {0x2206, 0x0ABF}, {0x2206, 0x348E}, {0x2206, 0x022C},
+	{0x2206, 0x31F6}, {0x2206, 0x06AE}, {0x2206, 0x0FF6}, {0x2206, 0x0302},
+	{0x2206, 0x0470}, {0x2206, 0xF703}, {0x2206, 0xF706}, {0x2206, 0xBF34},
+	{0x2206, 0x9302}, {0x2206, 0x2C31}, {0x2206, 0xAC1A}, {0x2206, 0x25E0},
+	{0x2206, 0xE022}, {0x2206, 0xE1E0}, {0x2206, 0x23EF}, {0x2206, 0x300D},
+	{0x2206, 0x311F}, {0x2206, 0x325B}, {0x2206, 0x029E}, {0x2206, 0x157A},
+	{0x2206, 0x0258}, {0x2206, 0xC4A0}, {0x2206, 0x0408}, {0x2206, 0xBF34},
+	{0x2206, 0x9E02}, {0x2206, 0x2C31}, {0x2206, 0xAE06}, {0x2206, 0xBF34},
+	{0x2206, 0x9C02}, {0x2206, 0x2C31}, {0x2206, 0xAC1B}, {0x2206, 0x4AE0},
+	{0x2206, 0xE012}, {0x2206, 0xE1E0}, {0x2206, 0x13EF}, {0x2206, 0x300D},
+	{0x2206, 0x331F}, {0x2206, 0x325B}, {0x2206, 0x1C9E}, {0x2206, 0x3AEF},
+	{0x2206, 0x325B}, {0x2206, 0x1C9F}, {0x2206, 0x09BF}, {0x2206, 0x3498},
+	{0x2206, 0x022C}, {0x2206, 0x3102}, {0x2206, 0x83C5}, {0x2206, 0x5A03},
+	{0x2206, 0x0D03}, {0x2206, 0x581C}, {0x2206, 0x1E20}, {0x2206, 0x0207},
+	{0x2206, 0xA0A0}, {0x2206, 0x000E}, {0x2206, 0x0284}, {0x2206, 0x17AD},
+	{0x2206, 0x1817}, {0x2206, 0xBF34}, {0x2206, 0x9A02}, {0x2206, 0x2C31},
+	{0x2206, 0xAE0F}, {0x2206, 0xBF34}, {0x2206, 0xC802}, {0x2206, 0x2C31},
+	{0x2206, 0xBF34}, {0x2206, 0xC502}, {0x2206, 0x2C31}, {0x2206, 0x0284},
+	{0x2206, 0x52E6}, {0x2206, 0x8AD2}, {0x2206, 0xEF97}, {0x2206, 0xFFFE},
+	{0x2206, 0xFDFC}, {0x2206, 0x04F8}, {0x2206, 0xBF34}, {0x2206, 0xDA02},
+	{0x2206, 0x2CE0}, {0x2206, 0xE58A}, {0x2206, 0xD3BF}, {0x2206, 0x34D4},
+	{0x2206, 0x022C}, {0x2206, 0xE00C}, {0x2206, 0x1159}, {0x2206, 0x02E0},
+	{0x2206, 0x8AD3}, {0x2206, 0x1E01}, {0x2206, 0xE48A}, {0x2206, 0xD3D1},
+	{0x2206, 0x00BF}, {0x2206, 0x34DA}, {0x2206, 0x022C}, {0x2206, 0xA2D1},
+	{0x2206, 0x01BF}, {0x2206, 0x34D4}, {0x2206, 0x022C}, {0x2206, 0xA2BF},
+	{0x2206, 0x34CB}, {0x2206, 0x022C}, {0x2206, 0xE0E5}, {0x2206, 0x8ACE},
+	{0x2206, 0xBF85}, {0x2206, 0x6702}, {0x2206, 0x2CE0}, {0x2206, 0xE58A},
+	{0x2206, 0xCFBF}, {0x2206, 0x8564}, {0x2206, 0x022C}, {0x2206, 0xE0E5},
+	{0x2206, 0x8AD0}, {0x2206, 0xBF85}, {0x2206, 0x6A02}, {0x2206, 0x2CE0},
+	{0x2206, 0xE58A}, {0x2206, 0xD1FC}, {0x2206, 0x04F8}, {0x2206, 0xE18A},
+	{0x2206, 0xD1BF}, {0x2206, 0x856A}, {0x2206, 0x022C}, {0x2206, 0xA2E1},
+	{0x2206, 0x8AD0}, {0x2206, 0xBF85}, {0x2206, 0x6402}, {0x2206, 0x2CA2},
+	{0x2206, 0xE18A}, {0x2206, 0xCFBF}, {0x2206, 0x8567}, {0x2206, 0x022C},
+	{0x2206, 0xA2E1}, {0x2206, 0x8ACE}, {0x2206, 0xBF34}, {0x2206, 0xCB02},
+	{0x2206, 0x2CA2}, {0x2206, 0xE18A}, {0x2206, 0xD3BF}, {0x2206, 0x34DA},
+	{0x2206, 0x022C}, {0x2206, 0xA2E1}, {0x2206, 0x8AD3}, {0x2206, 0x0D11},
+	{0x2206, 0xBF34}, {0x2206, 0xD402}, {0x2206, 0x2CA2}, {0x2206, 0xFC04},
+	{0x2206, 0xF9A0}, {0x2206, 0x0405}, {0x2206, 0xE38A}, {0x2206, 0xD4AE},
+	{0x2206, 0x13A0}, {0x2206, 0x0805}, {0x2206, 0xE38A}, {0x2206, 0xD5AE},
+	{0x2206, 0x0BA0}, {0x2206, 0x0C05}, {0x2206, 0xE38A}, {0x2206, 0xD6AE},
+	{0x2206, 0x03E3}, {0x2206, 0x8AD7}, {0x2206, 0xEF13}, {0x2206, 0xBF34},
+	{0x2206, 0xCB02}, {0x2206, 0x2CA2}, {0x2206, 0xEF13}, {0x2206, 0x0D11},
+	{0x2206, 0xBF85}, {0x2206, 0x6702}, {0x2206, 0x2CA2}, {0x2206, 0xEF13},
+	{0x2206, 0x0D14}, {0x2206, 0xBF85}, {0x2206, 0x6402}, {0x2206, 0x2CA2},
+	{0x2206, 0xEF13}, {0x2206, 0x0D17}, {0x2206, 0xBF85}, {0x2206, 0x6A02},
+	{0x2206, 0x2CA2}, {0x2206, 0xFD04}, {0x2206, 0xF8E0}, {0x2206, 0x8B85},
+	{0x2206, 0xAD27}, {0x2206, 0x2DE0}, {0x2206, 0xE036}, {0x2206, 0xE1E0},
+	{0x2206, 0x37E1}, {0x2206, 0x8B73}, {0x2206, 0x1F10}, {0x2206, 0x9E20},
+	{0x2206, 0xE48B}, {0x2206, 0x73AC}, {0x2206, 0x200B}, {0x2206, 0xAC21},
+	{0x2206, 0x0DAC}, {0x2206, 0x250F}, {0x2206, 0xAC27}, {0x2206, 0x0EAE},
+	{0x2206, 0x0F02}, {0x2206, 0x84CC}, {0x2206, 0xAE0A}, {0x2206, 0x0284},
+	{0x2206, 0xD1AE}, {0x2206, 0x05AE}, {0x2206, 0x0302}, {0x2206, 0x84D8},
+	{0x2206, 0xFC04}, {0x2206, 0xEE8B}, {0x2206, 0x6800}, {0x2206, 0x0402},
+	{0x2206, 0x84E5}, {0x2206, 0x0285}, {0x2206, 0x2804}, {0x2206, 0x0285},
+	{0x2206, 0x4904}, {0x2206, 0xEE8B}, {0x2206, 0x6800}, {0x2206, 0xEE8B},
+	{0x2206, 0x6902}, {0x2206, 0x04F8}, {0x2206, 0xF9E0}, {0x2206, 0x8B85},
+	{0x2206, 0xAD26}, {0x2206, 0x38D0}, {0x2206, 0x0B02}, {0x2206, 0x2B4D},
+	{0x2206, 0x5882}, {0x2206, 0x7882}, {0x2206, 0x9F2D}, {0x2206, 0xE08B},
+	{0x2206, 0x68E1}, {0x2206, 0x8B69}, {0x2206, 0x1F10}, {0x2206, 0x9EC8},
+	{0x2206, 0x10E4}, {0x2206, 0x8B68}, {0x2206, 0xE0E0}, {0x2206, 0x00E1},
+	{0x2206, 0xE001}, {0x2206, 0xF727}, {0x2206, 0xE4E0}, {0x2206, 0x00E5},
+	{0x2206, 0xE001}, {0x2206, 0xE2E0}, {0x2206, 0x20E3}, {0x2206, 0xE021},
+	{0x2206, 0xAD30}, {0x2206, 0xF7F6}, {0x2206, 0x27E4}, {0x2206, 0xE000},
+	{0x2206, 0xE5E0}, {0x2206, 0x01FD}, {0x2206, 0xFC04}, {0x2206, 0xF8FA},
+	{0x2206, 0xEF69}, {0x2206, 0xE08B}, {0x2206, 0x86AD}, {0x2206, 0x2212},
+	{0x2206, 0xE0E0}, {0x2206, 0x14E1}, {0x2206, 0xE015}, {0x2206, 0xAD26},
+	{0x2206, 0x9CE1}, {0x2206, 0x85E0}, {0x2206, 0xBF85}, {0x2206, 0x6D02},
+	{0x2206, 0x2CA2}, {0x2206, 0xEF96}, {0x2206, 0xFEFC}, {0x2206, 0x04F8},
+	{0x2206, 0xFAEF}, {0x2206, 0x69E0}, {0x2206, 0x8B86}, {0x2206, 0xAD22},
+	{0x2206, 0x09E1}, {0x2206, 0x85E1}, {0x2206, 0xBF85}, {0x2206, 0x6D02},
+	{0x2206, 0x2CA2}, {0x2206, 0xEF96}, {0x2206, 0xFEFC}, {0x2206, 0x0464},
+	{0x2206, 0xE48C}, {0x2206, 0xFDE4}, {0x2206, 0x80CA}, {0x2206, 0xE480},
+	{0x2206, 0x66E0}, {0x2206, 0x8E70}, {0x2206, 0xE076}, {0x2205, 0xE142},
+	{0x2206, 0x0701}, {0x2205, 0xE140}, {0x2206, 0x0405}, {0x220F, 0x0000},
+	{0x221F, 0x0000}, {0x2200, 0x1340}, {0x133E, 0x000E}, {0x133F, 0x0010},
+	{0x13EB, 0x11BB}
+};
+
+static const struct rtl8367b_initval rtl8367r_vb_initvals_1[] = {
 	{0x1B03, 0x0876}, {0x1200, 0x7FC4}, {0x1305, 0xC000}, {0x121E, 0x03CA},
 	{0x1233, 0x0352}, {0x1234, 0x0064}, {0x1237, 0x0096}, {0x1238, 0x0078},
 	{0x1239, 0x0084}, {0x123A, 0x0030}, {0x205F, 0x0002}, {0x2059, 0x1A00},
@@ -426,7 +698,7 @@ static const struct rtl8367b_initval rtl8367b_initvals[] = {
 	{0x133E, 0x000E}, {0x133F, 0x0010},
 };
 
-static const struct rtl8367b_initval rtl8367c_initvals[] = {
+static const struct rtl8367b_initval rtl8367c_initvals0[] = {
 	{0x13c2, 0x0000}, {0x0018, 0x0f00}, {0x0038, 0x0f00}, {0x0058, 0x0f00},
 	{0x0078, 0x0f00}, {0x0098, 0x0f00}, {0x1d15, 0x0a69}, {0x2000, 0x1340},
 	{0x2020, 0x1340}, {0x2040, 0x1340}, {0x2060, 0x1340}, {0x2080, 0x1340},
@@ -439,7 +711,32 @@ static const struct rtl8367b_initval rtl8367c_initvals[] = {
 	{0x0300, 0x0001}, {0x03fa, 0x0007}, {0x08c8, 0x00c0}, {0x0a30, 0x020e},
 	{0x0800, 0x0000}, {0x0802, 0x0000}, {0x09da, 0x0017}, {0x1d32, 0x0002},
 };
-
+static const struct rtl8367b_initval rtl8367s_initvals[] = {
+/* Special init for RTL8367SB in RGMII mode with some comments */
+/* phy port eee init */
+{0x0018, 0x0f00}, {0x1d15, 0x0a69}, {0x2014, 0x0000}, {0x2708, 0x0006},
+{0x0038, 0x0f00}, {0x1d15, 0x0a69}, {0x2034, 0x0000}, {0x2748, 0x0006},
+{0x0058, 0x0f00}, {0x1d15, 0x0a69}, {0x2054, 0x0000}, {0x2748, 0x0006},
+{0x0078, 0x0f00}, {0x1d15, 0x0a69}, {0x2074, 0x0000}, {0x2768, 0x0006},
+{0x0018, 0x0f00}, {0x1d15, 0x0a69}, {0x2094, 0x0000}, {0x2788, 0x0006},
+/* enable phy 0-4 - after reset phy is disabled */
+{0x1d15, 0x0a69}, {0x2000, 0x1340}, {0x2020, 0x1340}, {0x2040, 0x1340},
+{0x2060, 0x1340}, {0x2080, 0x1340},
+/* standard init */
+{0x13eb, 0x15bb}, {0x1303, 0x06d6}, {0x1304, 0x0700}, {0x13E2, 0x003F},
+{0x13F9, 0x0090},
+/* add init extended interface2 mode == rgmii explicitly */
+{0x1303, 0x0767}, {0x1304, 0x7777}, {0x1305, 0xc000}, {0x13E2, 0x01fd},
+{0x13c3, 0x0001}, {0x13c4, 0x1076}, {0x13c5, 0x000a},
+/*end init ext2 mode*/
+{0x121e, 0x03CA}, {0x1233, 0x0352}, {0x1237, 0x00a0}, {0x123a, 0x0030},
+{0x1239, 0x0084}, {0x0301, 0x1000}, {0x1349, 0x001F}, {0x18e0, 0x4004},
+{0x122b, 0x641c}, {0x1305, 0xc000}, {0x1200, 0x7fcb}, {0x0884, 0x0003},
+{0x06eb, 0x0001}, {0x00cf, 0xffff}, {0x00d0, 0x0007}, {0x00ce, 0x48b0},
+{0x0398, 0xffff}, {0x0399, 0x0007}, {0x0300, 0x0001}, {0x03fa, 0x0007},
+{0x08c8, 0x00c0}, {0x0a30, 0x020e}, {0x0800, 0x0000}, {0x0802, 0x0000},
+{0x09da, 0x0017}, {0x1d32, 0x0002}, {0x13c2, 0x0000}, 
+};
 static int rtl8367b_write_initvals(struct rtl8366_smi *smi,
 				  const struct rtl8367b_initval *initvals,
 				  int count)
@@ -447,6 +744,10 @@ static int rtl8367b_write_initvals(struct rtl8366_smi *smi,
 	int err;
 	int i;
 
+	if (rtl_device_id == 0x0020) {
+		return 0;
+	}
+
 	for (i = 0; i < count; i++)
 		REG_WR(smi, initvals[i].reg, initvals[i].val);
 
@@ -551,27 +852,43 @@ static int rtl8367b_write_phy_reg(struct rtl8366_smi *smi,
 static int rtl8367b_init_regs(struct rtl8366_smi *smi)
 {
 	const struct rtl8367b_initval *initvals;
+	u32 chip_ver;
+	u32 rlvid;
 	int count;
+	int err;
 
-	switch (smi->rtl8367b_chip) {
-	case RTL8367B_CHIP_RTL8367RB:
-	case RTL8367B_CHIP_RTL8367R_VB:
-		initvals = rtl8367b_initvals;
-		count = ARRAY_SIZE(rtl8367b_initvals);
+	REG_WR(smi, RTL8367B_RTL_MAGIC_ID_REG, RTL8367B_RTL_MAGIC_ID_VAL);
+	REG_RD(smi, RTL8367B_CHIP_VER_REG, &chip_ver);
+
+	rlvid = (chip_ver >> RTL8367B_CHIP_VER_RLVID_SHIFT) &
+		RTL8367B_CHIP_VER_RLVID_MASK;
+
+	if (of_device_is_compatible(smi->parent->of_node,
+				    "realtek,rtl8367s")) {
+		initvals = rtl8367c_initvals0;
+		count = ARRAY_SIZE(rtl8367c_initvals0);
+	} else {
+	switch (rlvid) {
+	case 0:
+		initvals = rtl8367r_vb_initvals_0;
+		count = ARRAY_SIZE(rtl8367r_vb_initvals_0);
 		break;
-	case RTL8367B_CHIP_RTL8367RB_VB:
-	case RTL8367B_CHIP_RTL8367S:
-	case RTL8367B_CHIP_RTL8367S_VB:
-		initvals = rtl8367c_initvals;
-		count = ARRAY_SIZE(rtl8367c_initvals);
-		if ((smi->rtl8367b_chip == RTL8367B_CHIP_RTL8367S_VB) && (smi->emu_vlanmc == NULL)) {
-			smi->emu_vlanmc = kzalloc(sizeof(struct rtl8366_vlan_mc) * smi->num_vlan_mc, GFP_KERNEL);
-			dev_info(smi->parent, "alloc vlan mc emulator");
-		}
+
+	case 1:
+		initvals = rtl8367r_vb_initvals_1;
+		count = ARRAY_SIZE(rtl8367r_vb_initvals_1);
 		break;
+
 	default:
+		dev_err(smi->parent, "unknow rlvid %u\n", rlvid);
 		return -ENODEV;
 	}
+	}
+
+	/* TODO: disable RLTP */
+
+	if(chip_ver == 0x0020)
+		return 0;
 
 	return rtl8367b_write_initvals(smi, initvals, count);
 }
@@ -604,8 +921,45 @@ static int rtl8367b_reset_chip(struct rtl8366_smi *smi)
 static int rtl8367b_extif_set_mode(struct rtl8366_smi *smi, int id,
 				   enum rtl8367_extif_mode mode)
 {
-	int err;
-	u32 data;
+	int err, i;
+	/* for SGMII, works (from rtl8367s_api.c in TL-R600VPN v4 GPL) */
+	unsigned int redData[][2] = {
+		{0x7180, 0x2},
+		{0x04D7, 0x0480},
+		{0xF994, 0x0481},
+		{0x31A2, 0x0482},
+		{0x6960, 0x0483},
+		{0x9728, 0x0484},
+		{0x9D85, 0x0423},
+		{0xD810, 0x0424},
+		{0x0F80, 0x0001}
+	};
+
+	/*
+	 * for HSGMII, works
+	 * (from rtl8367c_asicdrv_port.c in TL-R600VPN v4 GPL,
+	 * based on redDataHB and customized like redData)
+	 */
+	unsigned int redDataH[][2] = {
+		{0x7180, 0x2},
+		{0x82F0, 0x0500},
+		{0xF195, 0x0501},
+		{0x31A2, 0x0502},
+		{0x7960, 0x0503},
+		{0x9728, 0x0504},
+		{0x9D85, 0x0423},
+		{0xD810, 0x0424},
+		{0x0F80, 0x0001},
+		{0x83F2, 0x002E}
+	};
+
+	if ((mode == RTL8367S_EXTIF_MODE_SGMII ||
+	     mode == RTL8367S_EXTIF_MODE_HSGMII)
+	     && id != RTL8367_EXTIF1) {
+		dev_err(smi->parent,
+			"SGMII/HSGMII mode is only available in extif1\n");
+		return -EINVAL;
+	}
 
 	/* set port mode */
 	switch (mode) {
@@ -613,7 +967,7 @@ static int rtl8367b_extif_set_mode(struct rtl8366_smi *smi, int id,
 		REG_RMW(smi, RTL8367B_CHIP_DEBUG0_REG,
 			RTL8367B_DEBUG0_SEL33(id),
 			RTL8367B_DEBUG0_SEL33(id));
-		if (id <= 1) {
+		if (id <= RTL8367_EXTIF1) {
 			REG_RMW(smi, RTL8367B_CHIP_DEBUG0_REG,
 				RTL8367B_DEBUG0_DRI(id) |
 					RTL8367B_DEBUG0_DRI_RG(id) |
@@ -625,15 +979,6 @@ static int rtl8367b_extif_set_mode(struct rtl8366_smi *smi, int id,
 					RTL8367B_DEBUG1_DP_MASK(id),
 				(7 << RTL8367B_DEBUG1_DN_SHIFT(id)) |
 					(7 << RTL8367B_DEBUG1_DP_SHIFT(id)));
-			if ((smi->rtl8367b_chip == RTL8367B_CHIP_RTL8367S_VB) && (id == 1)) {
-				REG_RMW(smi, RTL8367D_REG_EXT_TXC_DLY, RTL8367D_EXT1_RGMII_TX_DLY_MASK, 0);
-				/* Configure RGMII/MII mux to port 7 if UTP_PORT4 is not RGMII mode */
-				REG_RD(smi, RTL8367D_REG_TOP_CON0, &data);
-				data &= RTL8367D_MAC4_SEL_EXT1_MASK;
-				if (data == 0)
-					REG_RMW(smi, RTL8367D_REG_TOP_CON0, RTL8367D_MAC7_SEL_EXT1_MASK, RTL8367D_MAC7_SEL_EXT1_MASK);
-				REG_RMW(smi, RTL8367D_REG_SDS1_MISC0, RTL8367D_SDS1_MODE_MASK, RTL8367D_PORT_SDS_MODE_DISABLE);
-			}
 		} else {
 			REG_RMW(smi, RTL8367B_CHIP_DEBUG2_REG,
 				RTL8367B_DEBUG2_DRI_EXT2 |
@@ -658,6 +1003,17 @@ static int rtl8367b_extif_set_mode(struct rtl8366_smi *smi, int id,
 			RTL8367B_DEBUG0_SEL33(id),
 			RTL8367B_DEBUG0_SEL33(id));
 		REG_RMW(smi, RTL8367B_EXT_RGMXF_REG(id), BIT(6), BIT(6));
+
+		if (of_device_is_compatible(smi->parent->of_node,
+					    "realtek,rtl8367s")) {
+			REG_RMW(smi, RTL8367S_EXT_TXC_DLY_REG,
+				RTL8367S_EXT_GMII_TX_DELAY_MASK
+					<< RTL8367S_EXT1_GMII_TX_DELAY_SHIFT |
+				RTL8367S_EXT_GMII_TX_DELAY_MASK
+					<< RTL8367S_EXT0_GMII_TX_DELAY_SHIFT,
+				5 << RTL8367S_EXT1_GMII_TX_DELAY_SHIFT |	/* shoud be configured */
+				6 << RTL8367S_EXT0_GMII_TX_DELAY_SHIFT);	/* in set_rgmii_delay? */
+		}
 		break;
 
 	case RTL8367_EXTIF_MODE_MII_MAC:
@@ -667,13 +1023,49 @@ static int rtl8367b_extif_set_mode(struct rtl8366_smi *smi, int id,
 		REG_RMW(smi, RTL8367B_EXT_RGMXF_REG(id), BIT(6), 0);
 		break;
 
+	case RTL8367S_EXTIF_MODE_SGMII:
+		if (!of_device_is_compatible(smi->parent->of_node,
+					     "realtek,rtl8367s"))
+			goto invalid_mode;
+
+		/* setup SerDes register for SGMII */
+		for (i = 0; i <= 7; i++) {
+			REG_WR(smi, RTL8367S_SDS_INDACS_DATA_REG, redData[i][0]);
+			REG_WR(smi, RTL8367S_SDS_INDACS_ADDR_REG, redData[i][1]);
+			REG_WR(smi, RTL8367S_SDS_INDACS_CMD_REG,
+				RTL8367S_SDS_CMD | RTL8367S_SDS_RWOP);
+		}
+		break;
+
+	case RTL8367S_EXTIF_MODE_HSGMII:
+		if (!of_device_is_compatible(smi->parent->of_node,
+					     "realtek,rtl8367s"))
+			goto invalid_mode;
+
+		/* setup SerDes register for HSGMII */
+		for (i = 0; i <= 8; i++) {
+			REG_WR(smi, RTL8367S_SDS_INDACS_DATA_REG, redDataH[i][0]);
+			REG_WR(smi, RTL8367S_SDS_INDACS_ADDR_REG, redDataH[i][1]);
+			REG_WR(smi, RTL8367S_SDS_INDACS_CMD_REG,
+				RTL8367S_SDS_CMD | RTL8367S_SDS_RWOP);
+		}
+		break;
+
 	default:
-		dev_err(smi->parent,
-			"invalid mode for external interface %d\n", id);
-		return -EINVAL;
+		goto invalid_mode;
 	}
 
-	if (id <= 1)
+	if (id == RTL8367_EXTIF1 &&
+	    of_device_is_compatible(smi->parent->of_node, "realtek,rtl8367s")) {
+		REG_RMW(smi, RTL8367S_SDS_MISC,	RTL8367S_CFG_MAC8_SEL_HSGMII_MASK,
+			(mode == RTL8367S_EXTIF_MODE_HSGMII)
+				? RTL8367S_CFG_MAC8_SEL_HSGMII_MASK : 0);
+		REG_RMW(smi, RTL8367S_SDS_MISC,	RTL8367S_CFG_MAC8_SEL_SGMII,
+			(mode == RTL8367S_EXTIF_MODE_SGMII)
+				? RTL8367S_CFG_MAC8_SEL_SGMII : 0);
+	}
+
+	if (id <= RTL8367_EXTIF1)
 		REG_RMW(smi, RTL8367B_DIS_REG,
 			RTL8367B_DIS_RGMII_MASK << RTL8367B_DIS_RGMII_SHIFT(id),
 			mode << RTL8367B_DIS_RGMII_SHIFT(id));
@@ -682,7 +1074,20 @@ static int rtl8367b_extif_set_mode(struct rtl8366_smi *smi, int id,
 			RTL8367B_DIS2_RGMII_MASK << RTL8367B_DIS2_RGMII_SHIFT,
 			mode << RTL8367B_DIS2_RGMII_SHIFT);
 
+	if (mode == RTL8367S_EXTIF_MODE_SGMII ||
+	    mode == RTL8367S_EXTIF_MODE_HSGMII) {
+		REG_WR(smi, RTL8367S_SDS_INDACS_DATA_REG, 0x7106);
+		REG_WR(smi, RTL8367S_SDS_INDACS_ADDR_REG, 0x0003);
+		REG_WR(smi, RTL8367S_SDS_INDACS_CMD_REG,
+				RTL8367S_SDS_CMD | RTL8367S_SDS_RWOP);
+	}
+
 	return 0;
+
+invalid_mode:
+	dev_err(smi->parent,
+		"invalid mode for external interface %d\n", id);
+	return -EINVAL;
 }
 
 static int rtl8367b_extif_set_force(struct rtl8366_smi *smi, int id,
@@ -692,31 +1097,37 @@ static int rtl8367b_extif_set_force(struct rtl8366_smi *smi, int id,
 	u32 val;
 	int err;
 
-	val = pa->speed & RTL8367B_DI_FORCE_SPEED_MASK;
+	if (id == RTL8367_EXTIF1 &&
+	    of_device_is_compatible(smi->parent->of_node, "realtek,rtl8367s")) {
+		REG_RMW(smi, RTL8367S_SDS_MISC, RTL8367S_CFG_SGMII_FDUP,
+			pa->duplex ? RTL8367S_CFG_SGMII_FDUP : 0);
+		REG_RMW(smi, RTL8367S_SDS_MISC, RTL8367S_CFG_SGMII_SPD_MASK,
+			pa->speed << RTL8367S_CFG_SGMII_SPD_SHIFT);
+		REG_RMW(smi, RTL8367S_SDS_MISC, RTL8367S_CFG_SGMII_LINK,
+			pa->link ? RTL8367S_CFG_SGMII_LINK : 0);
+		REG_RMW(smi, RTL8367S_SDS_MISC, RTL8367S_CFG_SGMII_TXFC,
+			pa->txpause ? RTL8367S_CFG_SGMII_TXFC : 0);
+		REG_RMW(smi, RTL8367S_SDS_MISC, RTL8367S_CFG_SGMII_RXFC,
+			pa->rxpause ? RTL8367S_CFG_SGMII_RXFC : 0);
+	}
+
+	mask = (RTL8367B_DI_FORCE_MODE |
+		RTL8367B_DI_FORCE_NWAY |
+		RTL8367B_DI_FORCE_TXPAUSE |
+		RTL8367B_DI_FORCE_RXPAUSE |
+		RTL8367B_DI_FORCE_LINK |
+		RTL8367B_DI_FORCE_DUPLEX |
+		RTL8367B_DI_FORCE_SPEED_MASK);
+
+	val = pa->speed;
+	val |= pa->force_mode ? RTL8367B_DI_FORCE_MODE : 0;
 	val |= pa->nway ? RTL8367B_DI_FORCE_NWAY : 0;
 	val |= pa->txpause ? RTL8367B_DI_FORCE_TXPAUSE : 0;
 	val |= pa->rxpause ? RTL8367B_DI_FORCE_RXPAUSE : 0;
 	val |= pa->link ? RTL8367B_DI_FORCE_LINK : 0;
 	val |= pa->duplex ? RTL8367B_DI_FORCE_DUPLEX : 0;
 
-	if (smi->rtl8367b_chip >= RTL8367B_CHIP_RTL8367S_VB) { /* Family D */
-		val |= (pa->speed << RTL8367D_PORT_STATUS_SPEED1_SHIFT) & RTL8367D_PORT_STATUS_SPEED1_MASK;
-		if (smi->cpu_port != UINT_MAX) {
-			REG_WR(smi, RTL8367D_REG_MAC0_FORCE_SELECT + smi->cpu_port, val);
-			REG_WR(smi, RTL8367D_REG_MAC0_FORCE_SELECT_EN + smi->cpu_port, pa->force_mode ? 0xffff : 0x0000);
-		}
-	} else {
-		val |= pa->force_mode ? RTL8367B_DI_FORCE_MODE : 0;
-		mask = (RTL8367B_DI_FORCE_MODE |
-			RTL8367B_DI_FORCE_NWAY |
-			RTL8367B_DI_FORCE_TXPAUSE |
-			RTL8367B_DI_FORCE_RXPAUSE |
-			RTL8367B_DI_FORCE_LINK |
-			RTL8367B_DI_FORCE_DUPLEX |
-			RTL8367B_DI_FORCE_SPEED_MASK);
-
-		REG_RMW(smi, RTL8367B_DI_FORCE_REG(id), mask, val);
-	}
+	REG_RMW(smi, RTL8367B_DI_FORCE_REG(id), mask, val);
 
 	return 0;
 }
@@ -761,62 +1172,37 @@ static int rtl8367b_extif_init(struct rtl8366_smi *smi, int id,
 						     cfg->rxdelay);
 		if (err)
 			return err;
+
+		if (of_device_is_compatible(smi->parent->of_node,
+					    "realtek,rtl8367s")) {
+			/* disable pre-emphasis */
+			REG_WR(smi, RTL8367S_SDS_INDACS_DATA_REG, 0x28A0);
+			REG_WR(smi, RTL8367S_SDS_INDACS_ADDR_REG, 0x0482);
+			REG_WR(smi, RTL8367S_SDS_INDACS_CMD_REG,
+					RTL8367S_SDS_CMD | RTL8367S_SDS_RWOP);
+		}
 	}
 
 	return 0;
 }
 
 #ifdef CONFIG_OF
-static int rtl8367b_extif_init_of(struct rtl8366_smi *smi,
+static int rtl8367b_extif_init_of(struct rtl8366_smi *smi, int id,
 				  const char *name)
 {
 	struct rtl8367_extif_config *cfg;
+	enum rtl8367_port_speed speed;
 	const __be32 *prop;
 	int size;
 	int err;
-	unsigned cpu_port;
-	unsigned id = UINT_MAX;
 
 	prop = of_get_property(smi->parent->of_node, name, &size);
-	if (!prop || (size != (10 * sizeof(*prop)))) {
-		dev_err(smi->parent, "%s property is not defined or invalid\n", name);
-		err = -EINVAL;
-		goto err_init;
-	}
+	if (!prop)
+		return rtl8367b_extif_init(smi, id, NULL);
 
-	cpu_port = be32_to_cpup(prop++);
-	switch (cpu_port) {
-	case RTL8367B_CPU_PORT_NUM:
-	case RTL8367B_CPU_PORT_NUM + 1:
-	case RTL8367B_CPU_PORT_NUM + 2:
-		if (smi->rtl8367b_chip == RTL8367B_CHIP_RTL8367R_VB) { /* for the RTL8367R-VB chip, cpu_port 5 corresponds to extif1 */
-			if (cpu_port == RTL8367B_CPU_PORT_NUM)
-				id = 1;
-			else {
-				dev_err(smi->parent, "wrong cpu_port %u in %s property\n", cpu_port, name);
-				err = -EINVAL;
-				goto err_init;
-			}
-		} else if (smi->rtl8367b_chip == RTL8367B_CHIP_RTL8367S_VB) { /* for the RTL8367S-VB chip, cpu_port 7 corresponds to extif1, cpu_port 6 corresponds to extif0 */
-			if (cpu_port != RTL8367B_CPU_PORT_NUM) {
-				id = cpu_port - RTL8367B_CPU_PORT_NUM - 1;
-			} else {
-				dev_err(smi->parent, "wrong cpu_port %u in %s property\n", cpu_port, name);
-				err = -EINVAL;
-				goto err_init;
-			}
-		} else {
-			id = cpu_port - RTL8367B_CPU_PORT_NUM;
-		}
-		if (smi->cpu_port == UINT_MAX) {
-			dev_info(smi->parent, "cpu_port:%u, assigned to extif%u\n", cpu_port, id);
-			smi->cpu_port = cpu_port;
-		}
-		break;
-	default:
-		dev_err(smi->parent, "wrong cpu_port %u in %s property\n", cpu_port, name);
-		err = -EINVAL;
-		goto err_init;
+	if (size != (9 * sizeof(*prop))) {
+		dev_err(smi->parent, "%s property is invalid\n", name);
+		return -EINVAL;
 	}
 
 	cfg = kzalloc(sizeof(struct rtl8367_extif_config), GFP_KERNEL);
@@ -831,26 +1217,100 @@ static int rtl8367b_extif_init_of(struct rtl8366_smi *smi,
 	cfg->ability.rxpause = be32_to_cpup(prop++);
 	cfg->ability.link = be32_to_cpup(prop++);
 	cfg->ability.duplex = be32_to_cpup(prop++);
-	cfg->ability.speed = be32_to_cpup(prop++);
+	speed = be32_to_cpup(prop++);
+	if (of_device_is_compatible(smi->parent->of_node, "realtek,rtl8367s") &&
+	    cfg->mode == RTL8367S_EXTIF_MODE_HSGMII)
+		speed = RTL8367_PORT_SPEED_1000;
+	cfg->ability.speed = speed;
 
 	err = rtl8367b_extif_init(smi, id, cfg);
 	kfree(cfg);
 
-err_init:
-	if (id != 0) rtl8367b_extif_init(smi, 0, NULL);
-	if (id != 1) rtl8367b_extif_init(smi, 1, NULL);
-	if (id != 2) rtl8367b_extif_init(smi, 2, NULL);
-
 	return err;
 }
 #else
-static int rtl8367b_extif_init_of(struct rtl8366_smi *smi,
+static int rtl8367b_extif_init_of(struct rtl8366_smi *smi, int id,
 				  const char *name)
 {
 	return -EINVAL;
 }
 #endif
 
+/* RTL8367S set led mode */
+static int rtl8367S_led_group_set_ports(struct rtl8366_smi *smi,
+                                       unsigned int group, u16 port_mask)
+{
+        u32 reg;
+        u32 s;
+        int err;
+
+        port_mask &= 0xff;
+        s = (group % 2) * 8;
+        reg = 0x1b24 + (group / 2);
+
+        REG_RMW(smi, reg, (0xff << s), port_mask << s);
+
+        return 0;
+}
+
+static int rtl8367S_led_group_set_mode(struct rtl8366_smi *smi,
+                                      unsigned int mode)
+{
+        u16 mask;
+        u16 set;
+        int err;
+
+        mode &= 0x3;
+
+        mask = (0x3 << 12) | BIT(14);
+        set = (mode << 12) | BIT(14);
+
+        REG_RMW(smi, 0x1b03, mask, set);
+
+        return 0;
+}
+
+static int rtl8367S_led_op_select_parallel(struct rtl8366_smi *smi)
+{
+        int err;
+
+        //REG_WR(smi, 0x1b00, 0x1472);
+	REG_RMW(smi, 0x1b00,BIT(0),0x0); //LEDOP_PARALLEL
+	REG_RMW(smi, 0x1b26, BIT(0),0x0); //Disable serial CLK mode
+	REG_RMW(smi, 0x1b26, BIT(1),0x0); //Disable serial DATA mode
+        return 0;
+}
+
+static int rtl8367S_led_blinkrate_set(struct rtl8366_smi *smi, unsigned int rate)
+{
+        u16 mask;
+        u16 set;
+        int err;
+
+        mask = 0x7 << 1;
+        set = (rate & 0x7) << 1;
+        REG_RMW(smi, 0x1b02, mask, set);
+
+        return 0;
+}
+
+
+static int rtl8367S_led_group_set_config(struct rtl8366_smi *smi,
+                                        unsigned int led, unsigned int cfg)
+{
+        u16 mask;
+        u16 set;
+        int err;
+
+        mask = (0xf << (led * 4)) | BIT(14);
+        set = (cfg & 0xf) << (led * 4);
+
+        REG_RMW(smi, 0x1b03, mask, set);
+        return 0;
+}
+
+/* RTL8367S set led mode */
+
 static int rtl8367b_setup(struct rtl8366_smi *smi)
 {
 	struct rtl8367_platform_data *pdata;
@@ -865,15 +1325,83 @@ static int rtl8367b_setup(struct rtl8366_smi *smi)
 
 	/* initialize external interfaces */
 	if (smi->parent->of_node) {
-		err = rtl8367b_extif_init_of(smi, "realtek,extif");
+		err = rtl8367b_extif_init_of(smi, RTL8367_EXTIF0,
+					     "realtek,extif0");
 		if (err)
 			return err;
+
+		err = rtl8367b_extif_init_of(smi, RTL8367_EXTIF1,
+					     "realtek,extif1");
+		if (err)
+			return err;
+
+		err = rtl8367b_extif_init_of(smi, RTL8367_EXTIF2,
+					     "realtek,extif2");
+		if (err)
+			return err;
+
+		if (of_device_is_compatible(smi->parent->of_node, "realtek,rtl8367s"))
+		{
+		//高低点平接反了需要设置
+		  /*u32 regValue;
+		  REG_RD(smi,RTL8367S_REG_LED_ACTIVE_LOW_CFG0, &regValue);
+		  dev_info(smi->parent, "CFG0 is %04x\n",regValue);
+		  regValue &= ~(RTL8367S_PORT0_LED_ACTIVE_LOW_MASK | RTL8367S_PORT1_LED_ACTIVE_LOW_MASK | 
+				RTL8367S_PORT2_LED_ACTIVE_LOW_MASK | RTL8367S_PORT3_LED_ACTIVE_LOW_MASK);
+		  REG_WR(smi, RTL8367S_REG_LED_ACTIVE_LOW_CFG0, regValue);
+		  REG_RD(smi, RTL8367S_REG_LED_ACTIVE_LOW_CFG0, &regValue);
+		  dev_info(smi->parent, "Updated CFG0: 0x%04x\n", regValue);*/
+
+
+        	  /* setup LEDs */
+      		  err = rtl8367S_led_group_set_ports(smi, 0, RTL8367S_PORTS_ALL); //初始化端口led
+
+        	  err = rtl8367S_led_group_set_mode(smi, 0);			//设置模式为0
+		  /*set  	led0    led1   led2
+		  mode 0	00   0010  0011  0100
+		  mode 1	01   0110  0111  1000
+		  mode 2	10   0001  0110  1001
+		  mode 3	11   1000  0110  0111*/
+        	  err = rtl8367S_led_op_select_parallel(smi);
+		  //1:scan mode 1471, 2:parallel mode 1472, 3:mdx mode (serial mode) 14F7
+
+        	  err = rtl8367S_led_blinkrate_set(smi, 1);
+		  //blinkRate | Support 6 blink rates LED blink rate at 43ms, 84ms, 120ms, 170ms, 340ms and 670ms
+		  //43ms 0,84ms 1 ,120ms 2,170ms 3, 340ms 4,670ms 5
+
+        	  err = rtl8367S_led_group_set_config(smi, 0, 2);
+		  //set led0 mode 2
+		  err = rtl8367S_led_group_set_config(smi, 1, 2);
+		  //set led1 mode 2
+		  err = rtl8367S_led_group_set_config(smi, 2, 2);
+		  //set led2 mode 
+		  /*  0000        LED_Off                
+		      0001        Dup/Col                
+		      0010        Link/Act               
+		      0011        Spd1000                
+		      0100        Spd100                 
+		      0101        Spd10                  
+	  	      0110        Spd1000/Act            
+		      0111        Spd100/Act             
+		      1000        Spd10/Act              
+		      1001        Spd100 (10)/Act        
+		      1010        Fiber                  
+		      1011        Fault                  
+		      1100        Link/Rx                
+		      1101        Link/Tx                
+		      1110        Master                 
+		      1111        Act                    
+		 */
+		}	  
+
 	} else {
-		err = rtl8367b_extif_init(smi, 0, pdata->extif0_cfg);
+		err = rtl8367b_extif_init(smi, RTL8367_EXTIF0,
+					  pdata->extif0_cfg);
 		if (err)
 			return err;
 
-		err = rtl8367b_extif_init(smi, 1, pdata->extif1_cfg);
+		err = rtl8367b_extif_init(smi, RTL8367_EXTIF1,
+					  pdata->extif1_cfg);
 		if (err)
 			return err;
 	}
@@ -975,12 +1503,8 @@ static int rtl8367b_get_vlan_4k(struct rtl8366_smi *smi, u32 vid,
 			 RTL8367B_TA_VLAN0_MEMBER_MASK;
 	vlan4k->untag = (data[0] >> RTL8367B_TA_VLAN0_UNTAG_SHIFT) &
 			RTL8367B_TA_VLAN0_UNTAG_MASK;
-	if (smi->rtl8367b_chip >= RTL8367B_CHIP_RTL8367S_VB) /* Family D */
-		vlan4k->fid = (data[1] >> RTL8367D_TA_VLAN1_FID_SHIFT) &
-				RTL8367D_TA_VLAN1_FID_MASK;
-	else
-		vlan4k->fid = (data[1] >> RTL8367B_TA_VLAN1_FID_SHIFT) &
-				RTL8367B_TA_VLAN1_FID_MASK;
+	vlan4k->fid = (data[1] >> RTL8367B_TA_VLAN1_FID_SHIFT) &
+		      RTL8367B_TA_VLAN1_FID_MASK;
 
 	return 0;
 }
@@ -995,7 +1519,7 @@ static int rtl8367b_set_vlan_4k(struct rtl8366_smi *smi,
 	if (vlan4k->vid >= RTL8367B_NUM_VIDS ||
 	    vlan4k->member > RTL8367B_TA_VLAN0_MEMBER_MASK ||
 	    vlan4k->untag > RTL8367B_UNTAG_MASK ||
-	    vlan4k->fid > ((smi->rtl8367b_chip >= RTL8367B_CHIP_RTL8367S_VB) ? RTL8367D_FIDMAX : RTL8367B_FIDMAX))
+	    vlan4k->fid > RTL8367B_FIDMAX)
 		return -EINVAL;
 
 	memset(data, 0, sizeof(data));
@@ -1004,24 +1528,15 @@ static int rtl8367b_set_vlan_4k(struct rtl8366_smi *smi,
 		  RTL8367B_TA_VLAN0_MEMBER_SHIFT;
 	data[0] |= (vlan4k->untag & RTL8367B_TA_VLAN0_UNTAG_MASK) <<
 		   RTL8367B_TA_VLAN0_UNTAG_SHIFT;
-
-	if (smi->rtl8367b_chip >= RTL8367B_CHIP_RTL8367S_VB) /* Family D */
-		data[1] = ((vlan4k->fid & RTL8367D_TA_VLAN1_FID_MASK) <<
-			   RTL8367D_TA_VLAN1_FID_SHIFT) | 12; /* ivl_svl - BIT(3), svlan_chek_ivl_svl - BIT(2) */
-	else
-		data[1] = (vlan4k->fid & RTL8367B_TA_VLAN1_FID_MASK) <<
-			   RTL8367B_TA_VLAN1_FID_SHIFT;
+	data[1] = (vlan4k->fid & RTL8367B_TA_VLAN1_FID_MASK) <<
+		  RTL8367B_TA_VLAN1_FID_SHIFT;
 
 	for (i = 0; i < ARRAY_SIZE(data); i++)
 		REG_WR(smi, RTL8367B_TA_WRDATA_REG(i), data[i]);
 
 	/* write VID */
-	if (smi->rtl8367b_chip >= RTL8367B_CHIP_RTL8367S_VB) /* Family D */
-		REG_WR(smi, RTL8367B_TA_ADDR_REG,
-		       vlan4k->vid & RTL8367D_TA_VLAN_VID_MASK);
-	else
-		REG_WR(smi, RTL8367B_TA_ADDR_REG,
-		       vlan4k->vid & RTL8367B_TA_VLAN_VID_MASK);
+	REG_WR(smi, RTL8367B_TA_ADDR_REG,
+	       vlan4k->vid & RTL8367B_TA_VLAN_VID_MASK);
 
 	/* write table access control word */
 	REG_WR(smi, RTL8367B_TA_CTRL_REG, RTL8367B_TA_CTRL_CVLAN_WRITE);
@@ -1041,14 +1556,6 @@ static int rtl8367b_get_vlan_mc(struct rtl8366_smi *smi, u32 index,
 	if (index >= RTL8367B_NUM_VLANS)
 		return -EINVAL;
 
-	if (smi->emu_vlanmc) { /* use vlan mc emulation */
-		vlanmc->vid = smi->emu_vlanmc[index].vid;
-		vlanmc->member = smi->emu_vlanmc[index].member;
-		vlanmc->fid = smi->emu_vlanmc[index].fid;
-		vlanmc->untag = smi->emu_vlanmc[index].untag;
-		return 0;
-	}
-
 	for (i = 0; i < ARRAY_SIZE(data); i++)
 		REG_RD(smi, RTL8367B_VLAN_MC_BASE(index) + i, &data[i]);
 
@@ -1074,17 +1581,9 @@ static int rtl8367b_set_vlan_mc(struct rtl8366_smi *smi, u32 index,
 	    vlanmc->priority > RTL8367B_PRIORITYMAX ||
 	    vlanmc->member > RTL8367B_VLAN_MC0_MEMBER_MASK ||
 	    vlanmc->untag > RTL8367B_UNTAG_MASK ||
-	    vlanmc->fid > ((smi->rtl8367b_chip >= RTL8367B_CHIP_RTL8367S_VB) ? RTL8367D_FIDMAX : RTL8367B_FIDMAX))
+	    vlanmc->fid > RTL8367B_FIDMAX)
 		return -EINVAL;
 
-	if (smi->emu_vlanmc) { /* use vlanmc emulation */
-		smi->emu_vlanmc[index].vid = vlanmc->vid;
-		smi->emu_vlanmc[index].member = vlanmc->member;
-		smi->emu_vlanmc[index].fid = vlanmc->fid;
-		smi->emu_vlanmc[index].untag = vlanmc->untag;
-		return 0;
-	}
-
 	data[0] = (vlanmc->member & RTL8367B_VLAN_MC0_MEMBER_MASK) <<
 		  RTL8367B_VLAN_MC0_MEMBER_SHIFT;
 	data[1] = (vlanmc->fid & RTL8367B_VLAN_MC1_FID_MASK) <<
@@ -1107,41 +1606,10 @@ static int rtl8367b_get_mc_index(struct rtl8366_smi *smi, int port, int *val)
 	if (port >= RTL8367B_NUM_PORTS)
 		return -EINVAL;
 
-	if (smi->rtl8367b_chip >= RTL8367B_CHIP_RTL8367S_VB) { /* Family D */
-		int i;
-		struct rtl8366_vlan_mc vlanmc;
-
-		err = rtl8366_smi_read_reg(smi, RTL8367D_VLAN_PVID_CTRL_REG(port), &data);
-
-		if (err) {
-			dev_err(smi->parent, "read pvid register 0x%04x fail", RTL8367D_VLAN_PVID_CTRL_REG(port));
-			return err;
-		}
-
-		data &= RTL8367D_VLAN_PVID_CTRL_MASK;
-		for (i = 0; i < smi->num_vlan_mc; i++) {
-			err = rtl8367b_get_vlan_mc(smi, i, &vlanmc);
-
-			if (err) {
-				dev_err(smi->parent, "get vlan mc index %d fail", i);
-				return err;
-			}
-
-			if (data == vlanmc.vid) break;
-		}
-
-		if (i < smi->num_vlan_mc) {
-			*val = i;
-		} else {
-			dev_err(smi->parent, "vlan mc index for pvid %d not found", data);
-			return -EINVAL;
-		}
-	} else {
-		REG_RD(smi, RTL8367B_VLAN_PVID_CTRL_REG(port), &data);
+	REG_RD(smi, RTL8367B_VLAN_PVID_CTRL_REG(port), &data);
 
-		*val = (data >> RTL8367B_VLAN_PVID_CTRL_SHIFT(port)) &
-			RTL8367B_VLAN_PVID_CTRL_MASK;
-	}
+	*val = (data >> RTL8367B_VLAN_PVID_CTRL_SHIFT(port)) &
+	       RTL8367B_VLAN_PVID_CTRL_MASK;
 
 	return 0;
 }
@@ -1151,28 +1619,7 @@ static int rtl8367b_set_mc_index(struct rtl8366_smi *smi, int port, int index)
 	if (port >= RTL8367B_NUM_PORTS || index >= RTL8367B_NUM_VLANS)
 		return -EINVAL;
 
-	if (smi->rtl8367b_chip >= RTL8367B_CHIP_RTL8367S_VB) { /* Family D */
-		int pvid, err;
-		struct rtl8366_vlan_mc vlanmc;
-
-		err = rtl8367b_get_vlan_mc(smi, index, &vlanmc);
-
-		if (err) {
-			dev_err(smi->parent, "get vlan mc index %d fail", index);
-			return err;
-		}
-
-		pvid = vlanmc.vid & RTL8367D_VLAN_PVID_CTRL_MASK;
-		err = rtl8366_smi_write_reg(smi, RTL8367D_VLAN_PVID_CTRL_REG(port), pvid);
-
-		if (err) {
-			dev_err(smi->parent, "set port %d pvid %d fail", port, pvid);
-			return err;
-		}
-
-		return 0;
-	} else
-		return rtl8366_smi_rmwr(smi, RTL8367B_VLAN_PVID_CTRL_REG(port),
+	return rtl8366_smi_rmwr(smi, RTL8367B_VLAN_PVID_CTRL_REG(port),
 				RTL8367B_VLAN_PVID_CTRL_MASK <<
 					RTL8367B_VLAN_PVID_CTRL_SHIFT(port),
 				(index & RTL8367B_VLAN_PVID_CTRL_MASK) <<
@@ -1229,16 +1676,17 @@ static int rtl8367b_sw_get_port_link(struct switch_dev *dev,
 				    struct switch_port_link *link)
 {
 	struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
-	u32 data = 0;
+	u32 data = 0, sds_misc = 0;
 	u32 speed;
 
 	if (port >= RTL8367B_NUM_PORTS)
 		return -EINVAL;
 
-	if (smi->rtl8367b_chip >= RTL8367B_CHIP_RTL8367S_VB) /* Family D */
-		rtl8366_smi_read_reg(smi, RTL8367D_PORT_STATUS_REG(port), &data);
-	else
-		rtl8366_smi_read_reg(smi, RTL8367B_PORT_STATUS_REG(port), &data);
+	if (port == 6 &&
+		of_device_is_compatible(smi->parent->of_node, "realtek,rtl8367s"))
+		rtl8366_smi_read_reg(smi, RTL8367S_SDS_MISC, &sds_misc);
+
+	rtl8366_smi_read_reg(smi, RTL8367B_PORT_STATUS_REG(port), &data);
 
 	link->link = !!(data & RTL8367B_PORT_STATUS_LINK);
 	if (!link->link)
@@ -1249,19 +1697,19 @@ static int rtl8367b_sw_get_port_link(struct switch_dev *dev,
 	link->tx_flow = !!(data & RTL8367B_PORT_STATUS_TXPAUSE);
 	link->aneg = !!(data & RTL8367B_PORT_STATUS_NWAY);
 
-	if (smi->rtl8367b_chip >= RTL8367B_CHIP_RTL8367S_VB) /* Family D */
-		speed = (data & RTL8367B_PORT_STATUS_SPEED_MASK) | ((data & RTL8367D_PORT_STATUS_SPEED1_MASK) >> RTL8367D_PORT_STATUS_SPEED1_SHIFT);
-	else
-		speed = (data & RTL8367B_PORT_STATUS_SPEED_MASK);
+	speed = (data & RTL8367B_PORT_STATUS_SPEED_MASK);
 	switch (speed) {
-	case RTL8367B_PORT_STATUS_SPEED_10:
+	case 0:
 		link->speed = SWITCH_PORT_SPEED_10;
 		break;
-	case RTL8367B_PORT_STATUS_SPEED_100:
+	case 1:
 		link->speed = SWITCH_PORT_SPEED_100;
 		break;
-	case RTL8367B_PORT_STATUS_SPEED_1000:
-		link->speed = SWITCH_PORT_SPEED_1000;
+	case 2:
+		link->speed = (((sds_misc & RTL8367S_CFG_MAC8_SEL_HSGMII_MASK)
+				>> RTL8367S_CFG_MAC8_SEL_HSGMII_SHIFT) == 1)
+				? SWITCH_PORT_SPEED_2500
+				: SWITCH_PORT_SPEED_1000;
 		break;
 	default:
 		link->speed = SWITCH_PORT_SPEED_UNKNOWN;
@@ -1474,14 +1922,13 @@ static int rtl8367b_mii_write(struct mii_bus *bus, int addr, int reg, u16 val)
 
 static int rtl8367b_detect(struct rtl8366_smi *smi)
 {
-	const char *chip_name = NULL;
+	const char *chip_name;
 	u32 chip_num;
 	u32 chip_ver;
+	u32 chip_mode;
 	int ret;
 
-	smi->emu_vlanmc = NULL;
-	smi->rtl8367b_chip = RTL8367B_CHIP_UNKNOWN;
-
+	/* TODO: improve chip detection */
 	rtl8366_smi_write_reg(smi, RTL8367B_RTL_MAGIC_ID_REG,
 			      RTL8367B_RTL_MAGIC_ID_VAL);
 
@@ -1499,44 +1946,47 @@ static int rtl8367b_detect(struct rtl8366_smi *smi)
 		return ret;
 	}
 
+	ret = rtl8366_smi_read_reg(smi, RTL8367B_CHIP_MODE_REG, &chip_mode);
+	if (ret) {
+		dev_err(smi->parent, "unable to read %s register\n",
+			"chip mode");
+		return ret;
+	}
+
+	dev_info(smi->parent,
+		"found chip num:%04x ver:%04x, mode:%04x\n",
+		chip_num, chip_ver, chip_mode);
+
+	/* rtl8367s: known chip num:6367 ver:00a0, mode:00a0 */
+
+	if (of_device_is_compatible(smi->parent->of_node, "realtek,rtl8367s")) {
+		if (chip_ver == 0x00a0)
+			chip_name = "8367S";
+		else
+			goto unknown_chip;
+	} else {
 	switch (chip_ver) {
-	case 0x0010:
-		if (chip_num == 0x6642) {
-			chip_name = "8367S-VB";
-			smi->rtl8367b_chip = RTL8367B_CHIP_RTL8367S_VB;
-		}
-		break;
 	case 0x0020:
-		if (chip_num == 0x6367) {
-			chip_name = "8367RB-VB";
-			smi->rtl8367b_chip = RTL8367B_CHIP_RTL8367RB_VB;
-		}
-		break;
-	case 0x00A0:
-		if (chip_num == 0x6367) {
-			chip_name = "8367S";
-			smi->rtl8367b_chip = RTL8367B_CHIP_RTL8367S;
-		}
-		break;
 	case 0x1000:
 		chip_name = "8367RB";
-		smi->rtl8367b_chip = RTL8367B_CHIP_RTL8367RB;
 		break;
 	case 0x1010:
 		chip_name = "8367R-VB";
-		smi->rtl8367b_chip = RTL8367B_CHIP_RTL8367R_VB;
-	}
-
-	if (!chip_name) {
-		dev_err(smi->parent,
-			"unknown chip (num:%04x ver:%04x)\n",
-			chip_num, chip_ver);
-		return -ENODEV;
+		break;
+	default:
+			goto unknown_chip;
+		}
 	}
 
-	dev_info(smi->parent, "RTL%s chip found (num:%04x ver:%04x)\n", chip_name, chip_num, chip_ver);
+	dev_info(smi->parent, "RTL%s chip found\n", chip_name);
 
 	return 0;
+
+unknown_chip:
+	dev_err(smi->parent,
+		"unknown chip num:%04x ver:%04x, mode:%04x\n",
+		chip_num, chip_ver, chip_mode);
+	return -ENODEV;
 }
 
 static struct rtl8366_smi_ops rtl8367b_smi_ops = {
@@ -1574,10 +2024,18 @@ static int  rtl8367b_probe(struct platform_device *pdev)
 	smi->cmd_write = 0xb8;
 	smi->ops = &rtl8367b_smi_ops;
 	smi->num_ports = RTL8367B_NUM_PORTS;
-	smi->cpu_port = UINT_MAX; /* not defined yet */
+	if (of_property_read_u32(pdev->dev.of_node, "cpu_port", &smi->cpu_port)
+	    || smi->cpu_port >= smi->num_ports) {
+		if (of_device_is_compatible(pdev->dev.of_node, "realtek,rtl8367s"))
+			smi->cpu_port = RTL8367S_CPU_PORT_NUM;
+		else
+		smi->cpu_port = RTL8367B_CPU_PORT_NUM;
+	}
 	smi->num_vlan_mc = RTL8367B_NUM_VLANS;
 	smi->mib_counters = rtl8367b_mib_counters;
 	smi->num_mib_counters = ARRAY_SIZE(rtl8367b_mib_counters);
+	if (of_device_is_compatible(pdev->dev.of_node, "realtek,rtl8367s"))
+		smi->phy_id = RTL8367S_PHY_ADDR;
 
 	err = rtl8366_smi_init(smi);
 	if (err)
@@ -1595,8 +2053,6 @@ static int  rtl8367b_probe(struct platform_device *pdev)
 	platform_set_drvdata(pdev, NULL);
 	rtl8366_smi_cleanup(smi);
  err_free_smi:
-	if (smi->emu_vlanmc)
-		kfree(smi->emu_vlanmc);
 	kfree(smi);
 	return err;
 }
@@ -1632,6 +2088,7 @@ static void rtl8367b_shutdown(struct platform_device *pdev)
 #ifdef CONFIG_OF
 static const struct of_device_id rtl8367b_match[] = {
 	{ .compatible = "realtek,rtl8367b" },
+	{ .compatible = "realtek,rtl8367s" },
 	{},
 };
 MODULE_DEVICE_TABLE(of, rtl8367b_match);
diff --git a/drivers/net/phy/swconfig_leds.c b/drivers/net/phy/swconfig_leds.c
index 1d309c046..67177fd88 100644
--- a/drivers/net/phy/swconfig_leds.c
+++ b/drivers/net/phy/swconfig_leds.c
@@ -16,6 +16,7 @@
 #include <linux/ctype.h>
 #include <linux/device.h>
 #include <linux/workqueue.h>
+#include <linux/version.h>
 
 #define SWCONFIG_LED_TIMER_INTERVAL	(HZ / 10)
 #define SWCONFIG_LED_NUM_PORTS		32
@@ -24,10 +25,12 @@
 #define SWCONFIG_LED_PORT_SPEED_10	0x02	/* 10 Mbps */
 #define SWCONFIG_LED_PORT_SPEED_100	0x04	/* 100 Mbps */
 #define SWCONFIG_LED_PORT_SPEED_1000	0x08	/* 1000 Mbps */
+#define SWCONFIG_LED_PORT_SPEED_2500	0x10	/* 2500 Mbps */
 #define SWCONFIG_LED_PORT_SPEED_ALL	(SWCONFIG_LED_PORT_SPEED_NA | \
 					 SWCONFIG_LED_PORT_SPEED_10 | \
 					 SWCONFIG_LED_PORT_SPEED_100 | \
-					 SWCONFIG_LED_PORT_SPEED_1000)
+					 SWCONFIG_LED_PORT_SPEED_1000 | \
+					 SWCONFIG_LED_PORT_SPEED_2500)
 
 #define SWCONFIG_LED_MODE_LINK		0x01
 #define SWCONFIG_LED_MODE_TX		0x02
@@ -494,6 +497,10 @@ swconfig_led_work_func(struct work_struct *work)
 					sw_trig->link_speed[i] =
 						SWCONFIG_LED_PORT_SPEED_1000;
 					break;
+				case SWITCH_PORT_SPEED_2500:
+					sw_trig->link_speed[i] =
+						SWCONFIG_LED_PORT_SPEED_2500;
+					break;
 				}
 			}
 		}
diff --git a/include/linux/rtl8367.h b/include/linux/rtl8367.h
index 14150393e..9698b7362 100644
--- a/include/linux/rtl8367.h
+++ b/include/linux/rtl8367.h
@@ -18,6 +18,8 @@ enum rtl8367_port_speed {
 	RTL8367_PORT_SPEED_10 = 0,
 	RTL8367_PORT_SPEED_100,
 	RTL8367_PORT_SPEED_1000,
+	RTL8367S_PORT_SPEED_500M,
+	RTL8367S_PORT_SPEED_2500M,
 };
 
 struct rtl8367_port_ability {
@@ -30,6 +32,12 @@ struct rtl8367_port_ability {
 	enum rtl8367_port_speed speed;
 };
 
+enum rtl8367_extif {
+	RTL8367_EXTIF0 = 0,
+	RTL8367_EXTIF1,
+	RTL8367_EXTIF2,
+};
+
 enum rtl8367_extif_mode {
 	RTL8367_EXTIF_MODE_DISABLED = 0,
 	RTL8367_EXTIF_MODE_RGMII,
@@ -39,9 +47,11 @@ enum rtl8367_extif_mode {
 	RTL8367_EXTIF_MODE_TMII_PHY,
 	RTL8367_EXTIF_MODE_GMII,
 	RTL8367_EXTIF_MODE_RGMII_33V,
-	RTL8367B_EXTIF_MODE_RMII_MAC = 7,
+	RTL8367B_EXTIF_MODE_RMII_MAC,
 	RTL8367B_EXTIF_MODE_RMII_PHY,
 	RTL8367B_EXTIF_MODE_RGMII_33V,
+	RTL8367S_EXTIF_MODE_SGMII,
+	RTL8367S_EXTIF_MODE_HSGMII,
 };
 
 struct rtl8367_extif_config {
diff --git a/include/linux/switch.h b/include/linux/switch.h
index 4e6238470..cfef1d951 100644
--- a/include/linux/switch.h
+++ b/include/linux/switch.h
@@ -45,6 +45,7 @@ enum switch_port_speed {
 	SWITCH_PORT_SPEED_10 = 10,
 	SWITCH_PORT_SPEED_100 = 100,
 	SWITCH_PORT_SPEED_1000 = 1000,
+	SWITCH_PORT_SPEED_2500 = 2500,
 };
 
 struct switch_port_link {
