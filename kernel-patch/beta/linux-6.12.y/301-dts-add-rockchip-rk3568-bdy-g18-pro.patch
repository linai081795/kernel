diff --git a/arch/arm64/boot/dts/rockchip/Makefile b/arch/arm64/boot/dts/rockchip/Makefile
index ca9e04c88..56589b742 100644
--- a/arch/arm64/boot/dts/rockchip/Makefile
+++ b/arch/arm64/boot/dts/rockchip/Makefile
@@ -164,6 +164,7 @@ dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3568-dg-tn3568.dtb
 dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3568-alark35-3500.dtb
 dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3568-ec-x.dtb
 dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3568-evb1-v10.dtb
+dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3568-bdy-g18-pro.dtb
 dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3568-fastrhino-r66s.dtb
 dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3568-fastrhino-r68s.dtb
 dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3568-hinlink-h66k.dtb
diff --git a/arch/arm64/boot/dts/rockchip/rk3568-bdy-g18-pro.dts b/arch/arm64/boot/dts/rockchip/rk3568-bdy-g18-pro.dts
new file mode 100644
index 000000000..bedf5e0b3
--- /dev/null
+++ b/arch/arm64/boot/dts/rockchip/rk3568-bdy-g18-pro.dts
@@ -0,0 +1,1045 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+
+/dts-v1/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/pwm/pwm.h>
+#include <dt-bindings/leds/common.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/soc/rockchip,vop2.h>
+#include <dt-bindings/pinctrl/rockchip.h>
+#include "rk3568.dtsi"
+
+/ {
+	model = "BDY-G18 AX3000 Router";
+	compatible = "bdy,g18-pro", "rockchip,rk3568";
+
+	aliases {
+		ethernet0 = &gmac0;
+		ethernet1 = &gmac1;
+		mmc0 = &sdhci;
+	};
+
+	chosen: chosen {
+		stdout-path = "serial2:1500000n8";
+	};
+
+	fiq-debugger {
+		compatible = "rockchip,fiq-debugger";
+		rockchip,serial-id = <2>;
+		rockchip,wake-irq = <0>;
+		/* If enable uart uses irq instead of fiq */
+		rockchip,irq-mode-enable = <1>;
+		rockchip,baudrate = <1500000>;  /* Only 115200 and 1500000 */
+		interrupts = <GIC_SPI 252 IRQ_TYPE_LEVEL_LOW>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&uart2m0_xfer>;
+		status = "okay";
+	};
+
+	debug: debug@fd904000 {
+		compatible = "rockchip,debug";
+		reg = <0x0 0xfd904000 0x0 0x1000>,
+			<0x0 0xfd905000 0x0 0x1000>,
+			<0x0 0xfd906000 0x0 0x1000>,
+			<0x0 0xfd907000 0x0 0x1000>;
+	};
+
+	dc_12v: dc-12v {
+		compatible = "regulator-fixed";
+		regulator-name = "dc_12v";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <12000000>;
+		regulator-max-microvolt = <12000000>;
+	};
+
+	vcc3v3_sys: vcc3v3-sys {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc3v3_sys";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		vin-supply = <&dc_12v>;
+	};
+
+	vcc5v0_sys: vcc5v0-sys {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_sys";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&dc_12v>;
+	};
+
+	vcc5v0_usb: vcc5v0-usb {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_usb";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&dc_12v>;
+	};
+
+	vcc5v0_host: vcc5v0-host-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_host";
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		enable-active-high;
+		gpio = <&gpio0 RK_PA6 GPIO_ACTIVE_HIGH>;
+		vin-supply = <&vcc5v0_usb>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&vcc5v0_host_en>;
+	};
+
+	vcc5v0_otg: vcc5v0-otg-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_otg";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		enable-active-high;
+		regulator-boot-on;
+		regulator-always-on;
+		gpio = <&gpio0 RK_PA5 GPIO_ACTIVE_HIGH>;
+		vin-supply = <&vcc5v0_usb>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&vcc5v0_otg_en>;
+	};
+
+	vcc3v3_lcd0_n: vcc3v3-lcd0-n {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc3v3_lcd0_n";
+		regulator-boot-on;
+		gpio = <&gpio0 RK_PC7 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+		pinctrl-0 = <&vcc3v3_lcd0_n_en>;
+		pinctrl-names = "default";
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+
+	};
+
+	vcc3v3_lcd1_n: vcc3v3-lcd1-n {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc3v3_lcd1_n";
+		regulator-boot-on;
+		gpio = <&gpio0 RK_PC5 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+		pinctrl-0 = <&vcc3v3_lcd1_n_en>;
+		pinctrl-names = "default";
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+
+	};
+
+	sdio_pwrseq: sdio-pwrseq {
+		compatible = "mmc-pwrseq-simple";
+		clocks = <&rk809 1>;
+		clock-names = "ext_clock";
+		pinctrl-names = "default";
+		pinctrl-0 = <&wifi_enable_h>;
+		post-power-on-delay-ms = <200>;
+		reset-gpios = <&gpio3 RK_PD5 GPIO_ACTIVE_LOW>;
+	};
+
+	vcc1v8_adc: vcc1v8-adc {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc1v8_adc";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		vin-supply = <&vcc3v3_sys>;
+	};
+
+	vcc2v5_ddr: vcc2v5-ddr {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc2v5-sys";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <2500000>;
+		regulator-max-microvolt = <2500000>;
+		vin-supply = <&vcc3v3_sys>;
+	};
+
+	vcc3v3_vga: vcc3v3-vga {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc3v3_vga";
+		regulator-always-on;
+		regulator-boot-on;
+		gpio = <&gpio0 RK_PD5 GPIO_ACTIVE_HIGH>;
+		pinctrl-0 = <&vcc3v3_vga_en>;
+		pinctrl-names = "default";
+		enable-active-high;
+		vin-supply = <&vcc3v3_sys>;
+	};
+
+	pcie30_avdd0v9: pcie30-avdd0v9 {
+		compatible = "regulator-fixed";
+		regulator-name = "pcie30_avdd0v9";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <900000>;
+		regulator-max-microvolt = <900000>;
+		vin-supply = <&vcc3v3_sys>;
+	};
+
+	pcie30_avdd1v8: pcie30-avdd1v8 {
+		compatible = "regulator-fixed";
+		regulator-name = "pcie30_avdd1v8";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		vin-supply = <&vcc3v3_sys>;
+	};
+
+	vcc3v3_pcie: vcc3v3-pcie {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc3v3_pcie";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		enable-active-high;
+		gpio = <&gpio0 RK_PD4 GPIO_ACTIVE_HIGH>;
+		pinctrl-0 = <&vcc3v3_pcie_en>;
+		pinctrl-names = "default";
+		startup-delay-us = <5000>;
+		vin-supply = <&vcc3v3_sys>;
+	};
+
+	vcc3v3_bu: c3v3_buvcc3v3-bu {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc3v3_bu";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		vin-supply = <&vcc5v0_sys>;
+	};
+
+	vcc_camera: vcc-camera-regulator {
+		compatible = "regulator-fixed";
+		gpio = <&gpio0 RK_PC1 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&camera_pwr>;
+		regulator-name = "vcc_camera";
+		enable-active-high;
+		regulator-always-on;
+		regulator-boot-on;
+	};
+
+	vdd_cpu: vdd-cpu {
+		compatible = "pwm-regulator";
+		rockchip,pwm_id = <0>;
+		rockchip,pwm_voltage = <900000>;
+		pwms = <&pwm0 0 25000 1>;
+		regulator-name = "vdd_cpu";
+		regulator-min-microvolt = <800000>;
+		regulator-max-microvolt = <1400000>;
+		regulator-init-microvolt = <1150000>;
+		regulator-enable-ramp-delay = <300>;
+		regulator-ramp-delay = <8000>;
+		regulator-always-on;
+		regulator-boot-on;
+	};
+
+	gmac0_xpcsclk: xpcs-gmac0-clock {
+		compatible = "fixed-clock";
+		clock-frequency = <125000000>;
+		clock-output-names = "clk_gmac0_xpcs_mii";
+		#clock-cells = <0>;
+	};
+
+	gmac1_xpcsclk: xpcs-gmac1-clock {
+		compatible = "fixed-clock";
+		clock-frequency = <125000000>;
+		clock-output-names = "clk_gmac1_xpcs_mii";
+		#clock-cells = <0>;
+	};
+
+	adc_keys: adc-keys {
+		compatible = "adc-keys";
+		io-channels = <&saradc 0>;
+		io-channel-names = "buttons";
+		keyup-threshold-microvolt = <1800000>;
+		poll-interval = <100>;
+		status = "okay";
+		recovery-key {
+			label = "F12";
+			linux,code = <KEY_F12>;
+			press-threshold-microvolt = <1750>;
+		};
+	};
+
+	leds {
+		compatible = "gpio-leds";
+		led-power {
+			label = "led-power";
+			default-state = "on";
+			gpios = <&gpio0 RK_PC4 GPIO_ACTIVE_HIGH>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&led_power_en>;
+		};
+	};
+
+	rtlgsw@0 {
+		compatible = "realtek,rtl8367s";
+		realtek,mdio = <&mdio0>;
+		mii-bus = <&mdio0>;
+		realtek,id = <29>;
+		phy-id = <29>;
+		cpu_port = <7>;
+
+		//txdelay, rxdelay, mode, ability.force_mode, ability.txpause, ability.rxpause, ability.link, ability.duplex, speed
+		//sgmii,
+		realtek,extif1 = <0 0 11 1 1 1 1 1 2>;
+		//rgmii
+		realtek,extif2 = <0 0 1 1 1 1 1 1 2>;
+		status = "okay";
+	};
+};
+
+&i2c0 {
+
+	status = "okay";
+
+	rk809: pmic@20 {
+		compatible = "rockchip,rk809";
+		reg = <0x20>;
+		interrupt-parent = <&gpio0>;
+		interrupts = <RK_PA3 IRQ_TYPE_LEVEL_LOW>;
+		pinctrl-names = "default", "pmic-sleep", "pmic-power-off", "pmic-reset";
+		pinctrl-0 = <&pmic_int>;
+		pinctrl-1 = <&soc_slppin_slp &rk817_slppin_slp>;
+		pinctrl-2 = <&soc_slppin_gpio &rk817_slppin_pwrdn>;
+		pinctrl-3 = <&soc_slppin_gpio &rk817_slppin_rst>;
+		rockchip,system-power-controller;
+		wakeup-source;
+		#clock-cells = <1>;
+		clock-output-names = "rk808-clkout1\0rk808-clkout2";
+		pmic-reset-func = <0>;
+		not-save-power-en = <1>;
+		vcc1-supply = <&vcc3v3_sys>;
+		vcc2-supply = <&vcc3v3_sys>;
+		vcc3-supply = <&vcc3v3_sys>;
+		vcc4-supply = <&vcc3v3_sys>;
+		vcc5-supply = <&vcc3v3_sys>;
+		vcc6-supply = <&vcc3v3_sys>;
+		vcc7-supply = <&vcc3v3_sys>;
+		vcc8-supply = <&vcc3v3_sys>;
+		vcc9-supply = <&vcc3v3_sys>;
+
+		pwrkey {
+			status = "okay";
+		};
+
+		pinctrl_rk8xx: pinctrl_rk8xx {
+			gpio-controller;
+			#gpio-cells = <2>;
+
+			rk817_slppin_null: rk817_slppin_null {
+				pins = "gpio_slp";
+				function = "pin_fun0";
+			};
+
+			rk817_slppin_slp: rk817_slppin_slp {
+				pins = "gpio_slp";
+				function = "pin_fun1";
+			};
+
+			rk817_slppin_pwrdn: rk817_slppin_pwrdn {
+				pins = "gpio_slp";
+				function = "pin_fun2";
+			};
+
+			rk817_slppin_rst: rk817_slppin_rst {
+				pins = "gpio_slp";
+				function = "pin_fun3";
+			};
+		};
+
+		regulators {
+
+			vdd_logic: DCDC_REG1 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-init-microvolt = <900000>;
+				regulator-ramp-delay = <6001>;
+				regulator-initial-mode = <2>;
+				regulator-name = "vdd_logic";
+
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vdd_gpu: DCDC_REG2 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-init-microvolt = <1000000>;
+				regulator-ramp-delay = <6001>;
+				regulator-initial-mode = <2>;
+				regulator-name = "vdd_gpu";
+
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcc_ddr: DCDC_REG3 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-initial-mode = <2>;
+				regulator-name = "vcc_ddr";
+
+				regulator-state-mem {
+					regulator-on-in-suspend;
+				};
+			};
+
+			vdd_npu: DCDC_REG4 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-init-microvolt = <1000000>;
+				regulator-ramp-delay = <6001>;
+				regulator-initial-mode = <2>;
+				regulator-name = "vdd_npu";
+
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vdda0v9_image: LDO_REG1 {
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-min-microvolt = <900000>;
+				regulator-max-microvolt = <900000>;
+				regulator-name = "vdda0v9_image";
+
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vdda_0v9: LDO_REG2 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <900000>;
+				regulator-max-microvolt = <900000>;
+				regulator-name = "vdda_0v9";
+
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vdda0v9_pmu: LDO_REG3 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <900000>;
+				regulator-max-microvolt = <900000>;
+				regulator-name = "vdda0v9_pmu";
+
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <900000>;
+				};
+			};
+
+			vccio_acodec: LDO_REG4 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <3000000>;
+				regulator-max-microvolt = <3000000>;
+				regulator-name = "vccio_acodec";
+
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vccio_sd: LDO_REG5 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-name = "vccio_sd";
+
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcc3v3_pmu: LDO_REG6 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-name = "vcc3v3_pmu";
+
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <3300000>;
+				};
+			};
+
+			vcca_1v8: LDO_REG7 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-name = "vcca_1v8";
+
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcca1v8_pmu: LDO_REG8 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-name = "vcca1v8_pmu";
+
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <1800000>;
+				};
+			};
+
+			vcca1v8_image: LDO_REG9 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-name = "vcca1v8_image";
+
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcc_1v8: DCDC_REG5 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-name = "vcc_1v8";
+
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcc_3v3: SWITCH_REG1 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-name = "vcc_3v3";
+
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcc3v3_sd: SWITCH_REG2 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-name = "vcc3v3_sd";
+
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+		};
+	};
+};
+
+&pinctrl {
+	usb {
+		vcc5v0_host_en: vcc5v0-host-en {
+			rockchip,pins = <0 RK_PA6 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+		
+		vcc5v0_otg_en: vcc5v0-otg-en {
+			rockchip,pins = <0 RK_PA5 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	regulator-en {
+		vcc3v3_lcd0_n_en: vcc3v3-lcd0-n-en {
+			rockchip,pins = <0 RK_PC7 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+		vcc3v3_lcd1_n_en: vcc3v3-lcd1-n-en {
+			rockchip,pins = <0 RK_PC5 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+		vcc3v3_vga_en: vcc3v3-vga-en {
+			rockchip,pins = <0 RK_PD5 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+		camera_pwr: camera-pwr {
+			rockchip,pins = <0 RK_PC1 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+		vcc3v3_pcie_en: vcc3v3-pcie-en {
+			rockchip,pins = <0 RK_PD4 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	sdio-pwrseq {
+		wifi_enable_h: wifi-enable-h {
+			rockchip,pins = <3 RK_PD5 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	pmic {
+	
+		pmic_int: pmic-intl {
+			rockchip,pins = <0 RK_PA3 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	
+		soc_slppin_gpio: soc-slppin-gpio {
+			rockchip,pins = <0 RK_PA2 0 &pcfg_output_low>;
+		};
+	
+		soc_slppin_slp:soc-slppin-slp {
+			rockchip,pins = <0 RK_PA2 1 &pcfg_pull_none>;
+		};
+	
+		soc_slppin_rst {
+			rockchip,pins = <0 RK_PA2 2 &pcfg_pull_none>;
+		};
+	};
+
+	pcie {
+		pcie30x1_reset_h: pcie30x1-reset-h {
+			rockchip,pins = <0 RK_PC3 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+		pcie30x2_reset_h: pcie30x2-reset-h {
+			rockchip,pins = <4 RK_PC4 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+		pcie2x1_reset_h: pcie2x1-reset-h {
+			rockchip,pins = <3 RK_PC1 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	gmac-reset {
+		gmac0_reset: gmac0-reset {
+			rockchip,pins = <1 RK_PB0 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+		gmac1_reset: gmac1-reset {
+			rockchip,pins = <1 RK_PB1 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	leds {
+		led_power_en: led-power-en {
+			rockchip,pins = <0 RK_PC4 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+};
+
+&cpu0 {
+	cpu-supply = <&vdd_cpu>;
+};
+
+&cpu1 {
+	cpu-supply = <&vdd_cpu>;
+};
+
+&cpu2 {
+	cpu-supply = <&vdd_cpu>;
+};
+
+&cpu3 {
+	cpu-supply = <&vdd_cpu>;
+};
+
+&tsadc {
+	rockchip,hw-tshut-mode = <1>;
+	rockchip,hw-tshut-polarity = <0>;
+	status = "okay";
+};
+
+&uart2 {
+	status = "okay";
+};
+
+&pcie30_phy_grf {
+};
+
+// 注意两条 pcie reset gpio 均与 NSY不同
+// fe270000
+// 这里需要更换uboot版本,因为只有支持的pcie拆分的才能启动这个
+// 不然开启就挂死,更换版本:https://github.com/Kwiboo/u-boot-rockchip
+// https://lists.denx.de/pipermail/u-boot/2023-August/525793.html
+// 这个pcie,可能需要打补丁,使用radxa 版本
+&pcie3x1 {
+		vpcie3v3-supply = <&vcc3v3_pcie>;
+		reset-gpios = <&gpio0 RK_PC3 GPIO_ACTIVE_HIGH>;
+		num-lanes = <0x1>; /*可能不生效,但是拆分需要打补丁,如果是吧,打补丁*/
+		pinctrl-0 = <&pcie30x1_reset_h>;
+		status = "disabled";
+};
+
+//fe280000
+&pcie3x2 {
+		vpcie3v3-supply = <&vcc3v3_pcie>;
+		reset-gpios = <&gpio4 RK_PC4 GPIO_ACTIVE_HIGH>;
+		status = "okay";
+		num-lanes = <0x2>;
+		pinctrl-0 = <&pcie30x2_reset_h>;
+};
+
+&pcie30phy {
+		data-lanes = <1 2>; //配置lan的通道树
+		status = "okay";
+};
+
+&combphy2 {
+		status = "okay";
+};
+
+&pcie2x1 {
+		reset-gpios = <&gpio3 RK_PC1 GPIO_ACTIVE_HIGH>;
+		pinctrl-0 = <&pcie2x1_reset_h>;
+		//for kernel.dts
+		rockchip,perst-inactive-ms = <500>;
+		status = "okay";
+};
+
+&mdio0 {
+	status = "okay";
+};
+
+&gmac0 {
+	status = "okay";
+	phy-mode = "rgmii";
+	snps,reset-gpio = <&gpio1 RK_PB0 GPIO_ACTIVE_LOW>;
+	snps,reset-active-low;
+	snps,reset-delays-us = <0 20000 100000>;
+	assigned-clocks = <&cru SCLK_GMAC0_RX_TX &cru SCLK_GMAC0>;
+	assigned-clock-parents = <&cru SCLK_GMAC0_RGMII_SPEED>;
+	assigned-clock-rates = <0 125000000>;
+	tx_delay = <0x3f>;
+	rx_delay = <0x2c>;
+	clock_in_out = "output";
+	pinctrl-names = "default";
+	pinctrl-0 = <&gmac0_miim &gmac0_tx_bus2 &gmac0_rx_bus2 &gmac0_rgmii_clk &gmac0_rgmii_bus>;
+	fixed-link {
+		speed = <1000>;
+		full-duplex;
+	};
+};
+
+&mdio1 {
+	status = "okay";
+};
+
+&pipe_phy_grf1 {
+	status = "okay";
+};
+
+&combphy1 {
+	rockchip,sgmii-mac-sel = <1>;
+	status = "okay";
+};
+
+&xpcs {
+	status = "okay";
+};
+
+&gmac1 {
+	assigned-clocks = <&cru SCLK_GMAC1_RX_TX>;
+	assigned-clock-parents = <&gmac1_xpcsclk>;
+	status = "okay";
+	phy-mode = "sgmii";
+	rockchip,pipegrf = <&pipegrf>;
+	rockchip,xpcs = <&xpcs>;
+	//snps,reset-gpio = <&gpio2 RK_PC2 GPIO_ACTIVE_LOW>;
+	//snps,reset-active-low;
+	//snps,reset-delays-us = <0 20000 100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&gmac1m1_miim>;
+	power-domains = <&power RK3568_PD_PIPE>;
+	phys = <&combphy1 PHY_TYPE_SGMII>;
+	fixed-link {
+		speed = <1000>;
+		full-duplex;
+	};
+};
+
+&usb_host0_ehci {
+	status = "okay";
+};
+
+&usb_host0_ohci {
+	status = "okay";
+	snps,dis_enblslpm_quirk;
+	snps,dis-u1-entry-quirk;
+	snps,dis-u2-entry-quirk;
+	snps,dis-u2-freeclk-exists-quirk;
+	snps,dis-del-phy-power-chg-quirk;
+	snps,dis-tx-ipgap-linecheck-quirk;
+	snps,dis_rxdet_inp3_quirk;
+	snps,xhci-trb-ent-quirk;
+	snps,parkmode-disable-ss-quirk;
+	quirk-skip-phy-init;
+};
+
+&usb_host0_xhci {
+	dr_mode = "host";//自动检测
+	//extcon = <&combphy0>;
+	status = "okay";
+	extcon = <&usb2phy0>; //超过rxda测试
+	snps,dis_enblslpm_quirk;
+	snps,dis-u1-entry-quirk;
+	snps,dis-u2-entry-quirk;
+	snps,dis-u2-freeclk-exists-quirk;
+	snps,dis-del-phy-power-chg-quirk;
+	snps,dis-tx-ipgap-linecheck-quirk;
+	snps,dis_rxdet_inp3_quirk;
+	snps,xhci-trb-ent-quirk;
+	snps,parkmode-disable-ss-quirk;
+	quirk-skip-phy-init;
+};
+
+&usb_host1_ehci {
+	status = "disabled";
+};
+
+&usb_host1_ohci {
+	status = "disabled";
+};
+
+&usb_host1_xhci {
+	dr_mode = "host";//自动检测
+	snps,dis_enblslpm_quirk;
+	snps,dis-u2-freeclk-exists-quirk;
+	snps,dis-del-phy-power-chg-quirk;
+	snps,dis-tx-ipgap-linecheck-quirk;
+	snps,dis_rxdet_inp3_quirk;
+	snps,xhci-trb-ent-quirk;
+	snps,parkmode-disable-ss-quirk;
+	status = "disabled";
+};
+
+&usb2phy0 {
+	status = "okay";
+};
+
+&usb2phy0_host {
+	phy-supply = <&vcc5v0_host>;
+	status = "okay";
+};
+
+&usb2phy0_otg {
+	phy-supply = <&vcc5v0_otg>;
+	status = "okay";
+};
+
+&usb2phy1 {
+	status = "disabled";
+};
+
+&usb2phy1_host {
+	phy-supply = <&vcc5v0_host>;
+	status = "disabled";
+};
+
+&usb2phy1_otg {
+	phy-supply = <&vcc5v0_host>;
+	status = "disabled";
+};
+
+&sata2 {
+	status = "disabled";
+};
+
+&pmu_io_domains {
+	status = "okay";
+	pmuio2-supply = <&vcc3v3_pmu>;
+	vccio1-supply = <&vcc_3v3>;
+	vccio3-supply = <&vcc_3v3>;
+	vccio4-supply = <&vcc_3v3>;
+	vccio5-supply = <&vcc_3v3>;
+	vccio6-supply = <&vcc_3v3>;
+	vccio7-supply = <&vcc_3v3>;
+};
+
+&pwm0 {
+	status = "okay";
+};
+
+&pwm1 {
+	status = "okay";
+};
+
+&pwm2 {
+	status = "disable";
+};
+
+&pwm3 {
+	status = "disable";
+};
+
+&power {
+	status = "okay";
+};
+
+&gpu {
+	mali-supply = <&vdd_gpu>;
+	status = "okay";
+};
+
+&vpu {
+	status = "okay";
+};
+
+&rga {
+	status = "okay";
+};
+
+&vepu {
+	status = "okay";
+};
+
+&vop {
+	status = "okay";
+};
+
+//sdhci@fe310000
+&sdhci {
+	max-frequency = <200000000>;
+	bus-width = <8>;
+	no-sdio;
+	no-sd;
+	supports-emmc;
+	non-removable;
+	mmc-hs200-1_8v;
+	pinctrl-names = "default";
+	pinctrl-0 = <&emmc_bus8 &emmc_clk &emmc_cmd &emmc_datastrobe>;
+	status = "okay";
+};
+
+//dwmmc@fe000000
+&sdmmc2 {
+	max-frequency = <150000000>;
+	fifo-depth = <256>;
+	no-sd;
+	no-mmc;
+	bus-width = <4>;
+	disable-wp;
+	cap-sd-highspeed;
+	cap-sdio-irq;
+	keep-power-in-suspend;
+	sd-uhs-sdr104;
+	mmc-pwrseq = <&sdio_pwrseq>;
+	non-removable;
+	pinctrl-names = "default";
+	pinctrl-0 = <&sdmmc2m0_bus4 &sdmmc2m0_cmd &sdmmc2m0_clk>;
+	status = "disabled";
+};
+
+//dwmmc@fe2b0000
+&sdmmc0 {
+	max-frequency = <150000000>;
+	fifo-depth = <256>;
+	no-sdio;
+	bus-width = <4>;
+	cap-mmc-highspeed;
+	cap-sd-highspeed;
+	disable-wp;
+	sd-uhs-sdr104;
+	vmmc-supply = <&vcc3v3_sd>;
+	vqmmc-supply = <&vccio_sd>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&sdmmc0_bus4 &sdmmc0_clk &sdmmc0_cmd &sdmmc0_det>;
+	status = "disabled";
+};
+
+&combphy0 {
+	status = "okay";
+};
+
+&csi_dphy {
+	status = "okay";
+};
+
+&sfc {
+	status = "okay";
+
+	flash@0 {
+		compatible = "spi-nor";
+		reg = <0>;
+		spi-max-frequency = <25000000>;
+		spi-rx-bus-width = <4>;
+		spi-tx-bus-width = <1>;
+	};
+};
+
+&rng {
+	status = "okay";
+};
+
+//i2c@fe5a0000
+&i2c1 {
+	status = "disabled";
+};
+
+&i2c4 {
+	status = "okay";
+};
+
+&i2c5 {
+	status = "disabled";
+};
+
+&wdt {
+	status = "okay";
+};
+
+&uart8 {
+	status = "disabled";
+};
+
+&pwm4 {
+	status = "disabled";
+};
+
+&pwm5 {
+	status = "disabled";
+};
+
+&pwm7 {
+	status = "disabled";
+};
+
+&pwm8 {
+	status = "disabled";
+};
+
+&pwm9 {
+	status = "disabled";
+};
+
+//fe720000
+&saradc {
+	status = "okay";
+	vref-supply = <&vcc1v8_adc>;
+};
diff --git a/drivers/net/phy/rtl8367b.c b/drivers/net/phy/rtl8367b.c
index 497bd08c8..3524cecf6 100644
--- a/drivers/net/phy/rtl8367b.c
+++ b/drivers/net/phy/rtl8367b.c
@@ -19,7 +19,6 @@
 #include <linux/delay.h>
 #include <linux/skbuff.h>
 #include <linux/rtl8367.h>
-#include <linux/version.h>
 
 #include "rtl8366_smi.h"
 
@@ -215,6 +214,95 @@
 
 #define RTL8367B_RTL_MAGIC_ID_REG		0x13c2
 #define   RTL8367B_RTL_MAGIC_ID_VAL		0x0249
+//---------------------RTL8367S---------------------------------------
+#define RTL8367S_EXT_TXC_DLY_REG		0x13f9
+#define   RTL8367S_EXT1_GMII_TX_DELAY_SHIFT	12
+#define   RTL8367S_EXT0_GMII_TX_DELAY_SHIFT	9
+#define   RTL8367S_EXT_GMII_TX_DELAY_MASK	GENMASK(2,0)
+
+#define RTL8367S_SDS_MISC			0x1d11
+#define   RTL8367S_CFG_SGMII_RXFC		BIT(14)
+#define   RTL8367S_CFG_SGMII_TXFC		BIT(13)
+#define   RTL8367S_CFG_MAC8_SEL_HSGMII_SHIFT	11
+#define   RTL8367S_CFG_MAC8_SEL_HSGMII_MASK	BIT(11)
+#define   RTL8367S_CFG_SGMII_FDUP		BIT(10)
+#define   RTL8367S_CFG_SGMII_LINK		BIT(9)
+#define   RTL8367S_CFG_SGMII_SPD_SHIFT		7
+#define   RTL8367S_CFG_SGMII_SPD_MASK		GENMASK(8,7)
+#define   RTL8367S_CFG_MAC8_SEL_SGMII		BIT(6)
+
+#define RTL8367S_SDS_INDACS_CMD_REG            0x6600
+#define   RTL8367S_SDS_CMD                       BIT(7)
+#define   RTL8367S_SDS_RWOP                      BIT(6)
+#define RTL8367S_SDS_INDACS_ADDR_REG           0x6601
+#define RTL8367S_SDS_INDACS_DATA_REG           0x6602
+#define RTL8367S_CPU_PORT_NUM       6
+
+//led 
+#define    RTL8367S_REG_LED_ACTIVE_LOW_CFG0    0x1b0e
+#define    RTL8367S_LED_ACTIVE_LOW_CFG0_DUMMY_15_OFFSET    15
+#define    RTL8367S_LED_ACTIVE_LOW_CFG0_DUMMY_15_MASK    0x8000
+#define    RTL8367S_PORT3_LED_ACTIVE_LOW_OFFSET    12
+#define    RTL8367S_PORT3_LED_ACTIVE_LOW_MASK    0x7000
+#define    RTL8367S_LED_ACTIVE_LOW_CFG0_DUMMY_11_OFFSET    11
+#define    RTL8367S_LED_ACTIVE_LOW_CFG0_DUMMY_11_MASK    0x800
+#define    RTL8367S_PORT2_LED_ACTIVE_LOW_OFFSET    8
+#define    RTL8367S_PORT2_LED_ACTIVE_LOW_MASK    0x700
+#define    RTL8367S_DUMMY_7_OFFSET    7
+#define    RTL8367S_DUMMY_7_MASK    0x80
+#define    RTL8367S_PORT1_LED_ACTIVE_LOW_OFFSET    4
+#define    RTL8367S_PORT1_LED_ACTIVE_LOW_MASK    0x70
+#define    RTL8367S_DUMMY_3_OFFSET    3
+#define    RTL8367S_DUMMY_3_MASK    0x8
+#define    RTL8367S_PORT0_LED_ACTIVE_LOW_OFFSET    0
+#define    RTL8367S_PORT0_LED_ACTIVE_LOW_MASK    0x7
+
+#define    RTL8367S_REG_LED_ACTIVE_LOW_CFG1    0x1b0f
+#define    RTL8367S_LED_ACTIVE_LOW_CFG1_DUMMY_15_OFFSET    15
+#define    RTL8367S_LED_ACTIVE_LOW_CFG1_DUMMY_15_MASK    0x8000
+#define    RTL8367S_PORT7_LED_ACTIVE_LOW_OFFSET    12
+#define    RTL8367S_PORT7_LED_ACTIVE_LOW_MASK    0x7000
+#define    RTL8367S_LED_ACTIVE_LOW_CFG1_DUMMY_11_OFFSET    11
+#define    RTL8367S_LED_ACTIVE_LOW_CFG1_DUMMY_11_MASK    0x800
+#define    RTL8367S_PORT6_LED_ACTIVE_LOW_OFFSET    8
+#define    RTL8367S_PORT6_LED_ACTIVE_LOW_MASK    0x700
+#define    RTL8367S_DUMMY_1b0f_b_OFFSET    7
+#define    RTL8367S_DUMMY_1b0f_b_MASK    0x80
+#define    RTL8367S_PORT5_LED_ACTIVE_LOW_OFFSET    4
+#define    RTL8367S_PORT5_LED_ACTIVE_LOW_MASK    0x70
+#define    RTL8367S_DUMMY_1b0f_a_OFFSET    3
+#define    RTL8367S_DUMMY_1b0f_a_MASK    0x8
+#define    RTL8367S_PORT4_LED_ACTIVE_LOW_OFFSET    0
+#define    RTL8367S_PORT4_LED_ACTIVE_LOW_MASK    0x7
+
+#define    RTL8367S_REG_LED_ACTIVE_LOW_CFG2    0x1b10
+#define    RTL8367S_DUMMY_1b10_b_OFFSET    7
+#define    RTL8367S_DUMMY_1b10_b_MASK    0xFF80
+#define    RTL8367S_PORT9_LED_ACTIVE_LOW_OFFSET    4
+#define    RTL8367S_PORT9_LED_ACTIVE_LOW_MASK    0x70
+#define    RTL8367S_DUMMY_1b10_a_OFFSET    3
+#define    RTL8367S_DUMMY_1b10_a_MASK    0x8
+#define    RTL8367S_PORT8_LED_ACTIVE_LOW_OFFSET    0
+#define    RTL8367S_PORT8_LED_ACTIVE_LOW_MASK    0x7
+
+#define RTL8367S_PORT_0                  BIT(0)
+#define RTL8367S_PORT_1                  BIT(1)
+#define RTL8367S_PORT_2                  BIT(2)
+#define RTL8367S_PORT_3                  BIT(3)
+#define RTL8367S_PORT_4                  BIT(4)
+#define RTL8367S_PORT_5                  BIT(5)
+#define RTL8367S_PORT_6                  BIT(6)
+#define RTL8367S_PORT_7                  BIT(7)
+#define RTL8367S_PORT_E1                 BIT(8)  /* external port 1 */
+#define RTL8367S_PORT_E0                 BIT(9)  /* external port 0 */
+
+#define RTL8367S_PORTS_ALL                                       \
+        (RTL8367S_PORT_0 | RTL8367S_PORT_1 | RTL8367S_PORT_2 |     \
+         RTL8367S_PORT_3 | RTL8367S_PORT_4 | RTL8367S_PORT_5 |     \
+         RTL8367S_PORT_6 | RTL8367S_PORT_7 | RTL8367S_PORT_E1 |    \
+         RTL8367S_PORT_E0)
+//-------------------RTL8367S--------------------------------------
+
 
 #define RTL8367B_IA_CTRL_REG			0x1f00
 #define   RTL8367B_IA_CTRL_RW(_x)		((_x) << 1)
@@ -385,6 +473,34 @@ rtl8367b_mib_counters[RTL8367B_NUM_MIB_COUNTERS] = {
 			return err;					\
 	} while (0)
 
+#define REG_RWBTS(_smi, _reg, _bits, _val)				\
+	do {								\
+		err = rtl8366_smi_rwbts(_smi, _reg, _bits, _val);	\
+		if (err)						\
+			return err; 				\
+	} while (0)
+
+#define REG_RWBT(_smi, _reg, _bit, _val)				\
+	do {								\
+		err = rtl8366_smi_rwbt(_smi, _reg, _bit, _val);	\
+		if (err)						\
+			return err; 				\
+	} while (0)
+
+#define REG_RDBT(_smi, _reg, _bit, _val)				\
+	do {								\
+		err = rtl8366_smi_rdbt(_smi, _reg, _bit, _val);	\
+		if (err)						\
+			return err; 				\
+	} while (0)
+
+#define REG_RDBTS(_smi, _reg, _bits, _val)				\
+	do {								\
+		err = rtl8366_smi_rdbts(_smi, _reg, _bits, _val);	\
+		if (err)						\
+			return err; 				\
+	} while (0)
+
 static const struct rtl8367b_initval rtl8367b_initvals[] = {
 	{0x1B03, 0x0876}, {0x1200, 0x7FC4}, {0x1305, 0xC000}, {0x121E, 0x03CA},
 	{0x1233, 0x0352}, {0x1234, 0x0064}, {0x1237, 0x0096}, {0x1238, 0x0078},
@@ -605,7 +721,119 @@ static int rtl8367b_extif_set_mode(struct rtl8366_smi *smi, int id,
 				   enum rtl8367_extif_mode mode)
 {
 	int err;
-	u32 data;
+	u32 data,option,regValue;
+
+	int i;
+	/* for SGMII, works (from rtl8367s_api.c in TL-R600VPN v4 GPL) */
+	unsigned int redData[][2] = {
+		{0x04D7, 0x0480},
+		{0xF994, 0x0481},
+		{0x21A2, 0x0482},
+		{0x6960, 0x0483},
+		{0x9728, 0x0484},
+		{0x9D85, 0x0423},
+		{0xD810, 0x0424},
+		{0x83F2, 0x002E}
+	};
+
+	unsigned int redDataSB[][2] = { 
+		{0x04D7, 0x0480}, 
+		{0xF994, 0x0481}, 
+		{0x2420, 0x0482}, 
+		{0x6960, 0x0483}, 
+		{0x9728, 0x0484}, 
+		{0x9D85, 0x0423}, 
+		{0xD810, 0x0424}, 
+		{0x83F2, 0x002E} 
+	};
+
+	unsigned int redDataH[][2] = {
+		{0x7180, 0x2},
+		{0x82F0, 0x0500},
+		{0xF195, 0x0501},
+		{0x31A2, 0x0502},
+		{0x7960, 0x0503},
+		{0x9728, 0x0504},
+		{0x9D85, 0x0423},
+		{0xD810, 0x0424},
+		{0x0F80, 0x0001},
+		{0x83F2, 0x002E}
+	};
+
+	unsigned int redData1[][2] =  { 
+		{0x82F1, 0x0500}, 
+		{0xF195, 0x0501}, 
+		{0x31A2, 0x0502}, 
+		{0x796C, 0x0503}, 
+		{0x9728, 0x0504}, 
+		{0x9D85, 0x0423}, 
+		{0xD810, 0x0424}, 
+		{0x0F80, 0x0001}, 
+		{0x83F2, 0x002E} 
+	};
+	unsigned int redData5[][2] =  { 
+		{0x82F1, 0x0500}, 
+		{0xF195, 0x0501}, 
+		{0x31A2, 0x0502}, 
+		{0x796C, 0x0503}, 
+		{0x9728, 0x0504}, 
+		{0x9D85, 0x0423}, 
+		{0xD810, 0x0424}, 
+		{0x0F80, 0x0001}, 
+		{0x83F2, 0x002E} 
+	};
+	unsigned int redData6[][2] =  { 
+		{0x82F1, 0x0500}, 
+		{0xF195, 0x0501}, 
+		{0x31A2, 0x0502}, 
+		{0x796C, 0x0503}, 
+		{0x9728, 0x0504}, 
+		{0x9D85, 0x0423}, 
+		{0xD810, 0x0424}, 
+		{0x0F80, 0x0001}, 
+		{0x83F2, 0x002E} 
+	};
+	unsigned int redData8[][2] =  { 
+		{0x82F1, 0x0500}, 
+		{0xF995, 0x0501}, 
+		{0x31A2, 0x0502}, 
+		{0x796C, 0x0503}, 
+		{0x9728, 0x0504}, 
+		{0x9D85, 0x0423}, 
+		{0xD810, 0x0424}, 
+		{0x0F80, 0x0001}, 
+		{0x83F2, 0x002E} 
+	};
+	unsigned int redData9[][2] =  { 
+		{0x82F1, 0x0500}, 
+		{0xF995, 0x0501}, 
+		{0x31A2, 0x0502}, 
+		{0x796C, 0x0503}, 
+		{0x9728, 0x0504}, 
+		{0x9D85, 0x0423}, 
+		{0xD810, 0x0424}, 
+		{0x0F80, 0x0001}, 
+		{0x83F2, 0x002E} 
+	};
+	unsigned int redDataHB[][2] = { 
+		{0x82F0, 0x0500}, 
+		{0xF195, 0x0501}, 
+		{0x31A2, 0x0502}, 
+		{0x7960, 0x0503}, 
+		{0x9728, 0x0504}, 
+		{0x9D85, 0x0423}, 
+		{0xD810, 0x0424}, 
+		{0x0F80, 0x0001}, 
+		{0x83F2, 0x002E} 
+	};
+
+	if ((mode == RTL8367S_EXTIF_MODE_SGMII ||
+	     mode == RTL8367S_EXTIF_MODE_HSGMII)
+	     && id != RTL8367_EXTIF1) {
+		dev_err(smi->parent,
+			"SGMII/HSGMII mode is only available in extif1\n");
+		return -EINVAL;
+	}
 
 	/* set port mode */
 	switch (mode) {
@@ -658,6 +886,16 @@ static int rtl8367b_extif_set_mode(struct rtl8366_smi *smi, int id,
 			RTL8367B_DEBUG0_SEL33(id),
 			RTL8367B_DEBUG0_SEL33(id));
 		REG_RMW(smi, RTL8367B_EXT_RGMXF_REG(id), BIT(6), BIT(6));
+		if (of_device_is_compatible(smi->parent->of_node,
+                                   "realtek,rtl8367s")) {
+	        REG_RMW(smi, RTL8367S_EXT_TXC_DLY_REG,
+	        RTL8367S_EXT_GMII_TX_DELAY_MASK
+	                << RTL8367S_EXT1_GMII_TX_DELAY_SHIFT |
+	        RTL8367S_EXT_GMII_TX_DELAY_MASK
+	                << RTL8367S_EXT0_GMII_TX_DELAY_SHIFT,
+	        5 << RTL8367S_EXT1_GMII_TX_DELAY_SHIFT |        /* shoud be configured */
+	        6 << RTL8367S_EXT0_GMII_TX_DELAY_SHIFT);        /* in set_rgmii_delay? */
+		}
 		break;
 
 	case RTL8367_EXTIF_MODE_MII_MAC:
@@ -666,11 +904,111 @@ static int rtl8367b_extif_set_mode(struct rtl8366_smi *smi, int id,
 		REG_RMW(smi, RTL8367B_BYPASS_LINE_RATE_REG, BIT(id), 0);
 		REG_RMW(smi, RTL8367B_EXT_RGMXF_REG(id), BIT(6), 0);
 		break;
+	case RTL8367S_EXTIF_MODE_SGMII:
+	     REG_WR(smi, 0x13C0, 0x0249);
+	     REG_RD(smi, 0x13C1, &option);
+             REG_WR(smi, 0x13C0, 0x0000);   
+	    if (!of_device_is_compatible(smi->parent->of_node,
+	                                 "realtek,rtl8367s"))
+	            goto invalid_mode;
+
+            if(option == 0)
+            {
+		/* setup SerDes register for SGMII */
+                for(i = 0; i <= 7; i++)
+                {
+			REG_WR(smi, RTL8367S_SDS_INDACS_DATA_REG, redData[i][0]);
+			REG_WR(smi, RTL8367S_SDS_INDACS_ADDR_REG, redData[i][1]);
+			REG_WR(smi, RTL8367S_SDS_INDACS_CMD_REG, 0x00C0);
+                }
+            }
+            else
+            {
+                for(i = 0; i <= 7; i++)
+                {
+			REG_WR(smi, RTL8367S_SDS_INDACS_DATA_REG, redDataSB[i][0]);
+			REG_WR(smi, RTL8367S_SDS_INDACS_ADDR_REG, redDataSB[i][1]);
+			REG_WR(smi, RTL8367S_SDS_INDACS_CMD_REG, 0x00C0);
+                }
+            }
+	    break;
+
+	case RTL8367S_EXTIF_MODE_HSGMII:
+	     REG_WR(smi, 0x13c2, 0x0249);
+	     REG_RD(smi, 0x1301, &regValue);
+	     REG_WR(smi, 0x13c2, 0x0000);
+	    if (!of_device_is_compatible(smi->parent->of_node,
+	                                 "realtek,rtl8367s"))
+	            goto invalid_mode;
+	    if ( ((regValue & 0x00F0) >> 4) == 0x0001)
+            {
+		    /* setup SerDes register for HSGMII */
+                    for(i = 0; i <= 8; i++)
+                    {
+			    REG_WR(smi, RTL8367S_SDS_INDACS_DATA_REG, redDataH[i][0]);
+			    REG_WR(smi, RTL8367S_SDS_INDACS_ADDR_REG, redDataH[i][1]);
+			    REG_WR(smi, RTL8367S_SDS_INDACS_CMD_REG, 0x00C0);
+                    }
+            }
+	    else if ( ((regValue & 0x00F0) >> 4) == 0x0005)
+	    {
+                    for(i = 0; i <= 8; i++)
+                    {
+                            REG_WR(smi, RTL8367S_SDS_INDACS_DATA_REG, redData5[i][0]);
+                            REG_WR(smi, RTL8367S_SDS_INDACS_ADDR_REG, redData5[i][1]);
+                            REG_WR(smi, RTL8367S_SDS_INDACS_CMD_REG, 0x00C0);
+                    }
+	    }
+            else if ( ((regValue & 0x00F0) >> 4) == 0x0006)
+            {
+                    for(i = 0; i <= 8; i++)
+                    {
+                            REG_WR(smi, RTL8367S_SDS_INDACS_DATA_REG, redData6[i][0]);
+                            REG_WR(smi, RTL8367S_SDS_INDACS_ADDR_REG, redData6[i][1]);
+                            REG_WR(smi, RTL8367S_SDS_INDACS_CMD_REG, 0x00C0);
+                    }
+            }
+            else if ( ((regValue & 0x00F0) >> 4) == 0x0008)
+            {
+                    for(i = 0; i <= 8; i++)
+                    {
+                            REG_WR(smi, RTL8367S_SDS_INDACS_DATA_REG, redData8[i][0]);
+                            REG_WR(smi, RTL8367S_SDS_INDACS_ADDR_REG, redData8[i][1]);
+                            REG_WR(smi, RTL8367S_SDS_INDACS_CMD_REG, 0x00C0);
+                    }
+            }
+            else if ( ((regValue & 0x00F0) >> 4) == 0x0009)
+            {
+                    for(i = 0; i <= 8; i++)
+                    {
+                            REG_WR(smi, RTL8367S_SDS_INDACS_DATA_REG, redData9[i][0]);
+                            REG_WR(smi, RTL8367S_SDS_INDACS_ADDR_REG, redData9[i][1]);
+                            REG_WR(smi, RTL8367S_SDS_INDACS_CMD_REG, 0x00C0);
+                    }
+            }
+	    else {
+                    for(i = 0; i <= 8; i++)
+                    {
+                            REG_WR(smi, RTL8367S_SDS_INDACS_DATA_REG, redDataHB[i][0]);
+                            REG_WR(smi, RTL8367S_SDS_INDACS_ADDR_REG, redDataHB[i][1]);
+                            REG_WR(smi, RTL8367S_SDS_INDACS_CMD_REG, 0x00C0);
+                    }
+	    }
+    	    break;
 
 	default:
-		dev_err(smi->parent,
-			"invalid mode for external interface %d\n", id);
-		return -EINVAL;
+		goto invalid_mode;
+	}
+
+	if (id == RTL8367_EXTIF1 &&
+        of_device_is_compatible(smi->parent->of_node, "realtek,rtl8367s")) {
+            REG_RMW(smi, RTL8367S_SDS_MISC, RTL8367S_CFG_MAC8_SEL_HSGMII_MASK,
+                    (mode == RTL8367S_EXTIF_MODE_HSGMII)
+                            ? RTL8367S_CFG_MAC8_SEL_HSGMII_MASK : 0);
+            REG_RMW(smi, RTL8367S_SDS_MISC, RTL8367S_CFG_MAC8_SEL_SGMII,
+                    (mode == RTL8367S_EXTIF_MODE_SGMII)
+                            ? RTL8367S_CFG_MAC8_SEL_SGMII : 0);
+
 	}
 
 	if (id <= 1)
@@ -682,7 +1020,17 @@ static int rtl8367b_extif_set_mode(struct rtl8366_smi *smi, int id,
 			RTL8367B_DIS2_RGMII_MASK << RTL8367B_DIS2_RGMII_SHIFT,
 			mode << RTL8367B_DIS2_RGMII_SHIFT);
 
+	if (mode == RTL8367S_EXTIF_MODE_SGMII ||  mode == RTL8367S_EXTIF_MODE_HSGMII) {
+            REG_WR(smi, RTL8367S_SDS_INDACS_DATA_REG, 0x7106);
+            REG_WR(smi, RTL8367S_SDS_INDACS_ADDR_REG, 0x0003);
+            REG_WR(smi, RTL8367S_SDS_INDACS_CMD_REG, 0x00C0);
+        }
 	return 0;
+
+invalid_mode:
+		dev_err(smi->parent,
+			"invalid mode for external interface %d\n", id);
+		return -EINVAL;
 }
 
 static int rtl8367b_extif_set_force(struct rtl8366_smi *smi, int id,
@@ -699,6 +1047,20 @@ static int rtl8367b_extif_set_force(struct rtl8366_smi *smi, int id,
 	val |= pa->link ? RTL8367B_DI_FORCE_LINK : 0;
 	val |= pa->duplex ? RTL8367B_DI_FORCE_DUPLEX : 0;
 
+	if (id == RTL8367_EXTIF1 &&
+            of_device_is_compatible(smi->parent->of_node, "realtek,rtl8367s")) {
+            REG_RMW(smi, RTL8367S_SDS_MISC, RTL8367S_CFG_SGMII_FDUP,
+                    pa->duplex ? RTL8367S_CFG_SGMII_FDUP : 0);
+            REG_RMW(smi, RTL8367S_SDS_MISC, RTL8367S_CFG_SGMII_SPD_MASK,
+                    pa->speed << RTL8367S_CFG_SGMII_SPD_SHIFT);
+            REG_RMW(smi, RTL8367S_SDS_MISC, RTL8367S_CFG_SGMII_LINK,
+                    pa->link ? RTL8367S_CFG_SGMII_LINK : 0);
+            REG_RMW(smi, RTL8367S_SDS_MISC, RTL8367S_CFG_SGMII_TXFC,
+                    pa->txpause ? RTL8367S_CFG_SGMII_TXFC : 0);
+            REG_RMW(smi, RTL8367S_SDS_MISC, RTL8367S_CFG_SGMII_RXFC,
+                    pa->rxpause ? RTL8367S_CFG_SGMII_RXFC : 0);
+        }
+
 	if (smi->rtl8367b_chip >= RTL8367B_CHIP_RTL8367S_VB) { /* Family D */
 		val |= (pa->speed << RTL8367D_PORT_STATUS_SPEED1_SHIFT) & RTL8367D_PORT_STATUS_SPEED1_MASK;
 		if (smi->cpu_port != UINT_MAX) {
@@ -752,6 +1114,15 @@ static int rtl8367b_extif_init(struct rtl8366_smi *smi, int id,
 	if (err)
 		return err;
 
+	if (of_device_is_compatible(smi->parent->of_node,
+                                "realtek,rtl8367s")) {
+		    /* disable pre-emphasis */
+		    REG_WR(smi, RTL8367S_SDS_INDACS_DATA_REG, 0x28A0);
+		    REG_WR(smi, RTL8367S_SDS_INDACS_ADDR_REG, 0x0482);
+		    REG_WR(smi, RTL8367S_SDS_INDACS_CMD_REG,
+		           RTL8367S_SDS_CMD | RTL8367S_SDS_RWOP);
+	}
+
 	if (mode != RTL8367_EXTIF_MODE_DISABLED) {
 		err = rtl8367b_extif_set_force(smi, id, &cfg->ability);
 		if (err)
@@ -767,56 +1138,22 @@ static int rtl8367b_extif_init(struct rtl8366_smi *smi, int id,
 }
 
 #ifdef CONFIG_OF
-static int rtl8367b_extif_init_of(struct rtl8366_smi *smi,
+static int rtl8367b_extif_init_of(struct rtl8366_smi *smi,int id,
 				  const char *name)
 {
 	struct rtl8367_extif_config *cfg;
+	enum rtl8367_port_speed speed;
 	const __be32 *prop;
 	int size;
 	int err;
-	unsigned cpu_port;
-	unsigned id = UINT_MAX;
 
 	prop = of_get_property(smi->parent->of_node, name, &size);
-	if (!prop || (size != (10 * sizeof(*prop)))) {
-		dev_err(smi->parent, "%s property is not defined or invalid\n", name);
-		err = -EINVAL;
-		goto err_init;
-	}
+	if (!prop)
+		return rtl8367b_extif_init(smi, id, NULL);
 
-	cpu_port = be32_to_cpup(prop++);
-	switch (cpu_port) {
-	case RTL8367B_CPU_PORT_NUM:
-	case RTL8367B_CPU_PORT_NUM + 1:
-	case RTL8367B_CPU_PORT_NUM + 2:
-		if (smi->rtl8367b_chip == RTL8367B_CHIP_RTL8367R_VB) { /* for the RTL8367R-VB chip, cpu_port 5 corresponds to extif1 */
-			if (cpu_port == RTL8367B_CPU_PORT_NUM)
-				id = 1;
-			else {
-				dev_err(smi->parent, "wrong cpu_port %u in %s property\n", cpu_port, name);
-				err = -EINVAL;
-				goto err_init;
-			}
-		} else if (smi->rtl8367b_chip == RTL8367B_CHIP_RTL8367S_VB) { /* for the RTL8367S-VB chip, cpu_port 7 corresponds to extif1, cpu_port 6 corresponds to extif0 */
-			if (cpu_port != RTL8367B_CPU_PORT_NUM) {
-				id = cpu_port - RTL8367B_CPU_PORT_NUM - 1;
-			} else {
-				dev_err(smi->parent, "wrong cpu_port %u in %s property\n", cpu_port, name);
-				err = -EINVAL;
-				goto err_init;
-			}
-		} else {
-			id = cpu_port - RTL8367B_CPU_PORT_NUM;
-		}
-		if (smi->cpu_port == UINT_MAX) {
-			dev_info(smi->parent, "cpu_port:%u, assigned to extif%u\n", cpu_port, id);
-			smi->cpu_port = cpu_port;
-		}
-		break;
-	default:
-		dev_err(smi->parent, "wrong cpu_port %u in %s property\n", cpu_port, name);
-		err = -EINVAL;
-		goto err_init;
+	if (size != (9 * sizeof(*prop))) {
+		dev_err(smi->parent, "%s property is invalid\n", name);
+		return -EINVAL;
 	}
 
 	cfg = kzalloc(sizeof(struct rtl8367_extif_config), GFP_KERNEL);
@@ -831,26 +1168,100 @@ static int rtl8367b_extif_init_of(struct rtl8366_smi *smi,
 	cfg->ability.rxpause = be32_to_cpup(prop++);
 	cfg->ability.link = be32_to_cpup(prop++);
 	cfg->ability.duplex = be32_to_cpup(prop++);
-	cfg->ability.speed = be32_to_cpup(prop++);
+
+	speed = be32_to_cpup(prop++);
+	if (of_device_is_compatible(smi->parent->of_node, "realtek,rtl8367s") && cfg->mode == RTL8367S_EXTIF_MODE_HSGMII)
+        	speed = RTL8367_PORT_SPEED_1000;
+	cfg->ability.speed = speed;
 
 	err = rtl8367b_extif_init(smi, id, cfg);
 	kfree(cfg);
 
-err_init:
-	if (id != 0) rtl8367b_extif_init(smi, 0, NULL);
-	if (id != 1) rtl8367b_extif_init(smi, 1, NULL);
-	if (id != 2) rtl8367b_extif_init(smi, 2, NULL);
-
 	return err;
 }
 #else
-static int rtl8367b_extif_init_of(struct rtl8366_smi *smi,
+static int rtl8367b_extif_init_of(struct rtl8366_smi *smi,int id,
 				  const char *name)
 {
 	return -EINVAL;
 }
 #endif
 
+/* RTL8367S set led mode */
+static int rtl8367S_led_group_set_ports(struct rtl8366_smi *smi,
+                                       unsigned int group, u16 port_mask)
+{
+        u32 reg;
+        u32 s;
+        int err;
+
+        port_mask &= 0xff;
+        s = (group % 2) * 8;
+        reg = 0x1b24 + (group / 2);
+
+        REG_RMW(smi, reg, (0xff << s), port_mask << s);
+
+        return 0;
+}
+
+static int rtl8367S_led_group_set_mode(struct rtl8366_smi *smi,
+                                      unsigned int mode)
+{
+        u16 mask;
+        u16 set;
+        int err;
+
+        mode &= 0x3;
+
+        mask = (0x3 << 12) | BIT(14);
+        set = (mode << 12) | BIT(14);
+
+        REG_RMW(smi, 0x1b03, mask, set);
+
+        return 0;
+}
+
+static int rtl8367S_led_op_select_parallel(struct rtl8366_smi *smi)
+{
+        int err;
+
+        //REG_WR(smi, 0x1b00, 0x1472);
+	REG_RMW(smi, 0x1b00,BIT(0),0x0); //LEDOP_PARALLEL
+	REG_RMW(smi, 0x1b26, BIT(0),0x0); //Disable serial CLK mode
+	REG_RMW(smi, 0x1b26, BIT(1),0x0); //Disable serial DATA mode
+        return 0;
+}
+
+static int rtl8367S_led_blinkrate_set(struct rtl8366_smi *smi, unsigned int rate)
+{
+        u16 mask;
+        u16 set;
+        int err;
+
+        mask = 0x7 << 1;
+        set = (rate & 0x7) << 1;
+        REG_RMW(smi, 0x1b02, mask, set);
+
+        return 0;
+}
+
+
+static int rtl8367S_led_group_set_config(struct rtl8366_smi *smi,
+                                        unsigned int led, unsigned int cfg)
+{
+        u16 mask;
+        u16 set;
+        int err;
+
+        mask = (0xf << (led * 4)) | BIT(14);
+        set = (cfg & 0xf) << (led * 4);
+
+        REG_RMW(smi, 0x1b03, mask, set);
+        return 0;
+}
+
+/* RTL8367S set led mode */
+
 static int rtl8367b_setup(struct rtl8366_smi *smi)
 {
 	struct rtl8367_platform_data *pdata;
@@ -865,9 +1276,72 @@ static int rtl8367b_setup(struct rtl8366_smi *smi)
 
 	/* initialize external interfaces */
 	if (smi->parent->of_node) {
-		err = rtl8367b_extif_init_of(smi, "realtek,extif");
+		err = rtl8367b_extif_init_of(smi, 0,"realtek,extif0"); //port 5
+		if (err)
+			return err;
+
+		err = rtl8367b_extif_init_of(smi, 1, "realtek,extif1"); //port 6
 		if (err)
 			return err;
+
+		err = rtl8367b_extif_init_of(smi, 2, "realtek,extif2"); //port 7
+		if (err)
+			return err;
+	
+		if (of_device_is_compatible(smi->parent->of_node, "realtek,rtl8367s"))
+		{
+		//高低点平接反了需要设置
+		  /*u32 regValue;
+		  REG_RD(smi,RTL8367S_REG_LED_ACTIVE_LOW_CFG0, &regValue);
+		  dev_info(smi->parent, "CFG0 is %04x\n",regValue);
+		  regValue &= ~(RTL8367S_PORT0_LED_ACTIVE_LOW_MASK | RTL8367S_PORT1_LED_ACTIVE_LOW_MASK | 
+				RTL8367S_PORT2_LED_ACTIVE_LOW_MASK | RTL8367S_PORT3_LED_ACTIVE_LOW_MASK);
+		  REG_WR(smi, RTL8367S_REG_LED_ACTIVE_LOW_CFG0, regValue);
+		  REG_RD(smi, RTL8367S_REG_LED_ACTIVE_LOW_CFG0, &regValue);
+		  dev_info(smi->parent, "Updated CFG0: 0x%04x\n", regValue);*/
+
+
+        	  /* setup LEDs */
+      		  err = rtl8367S_led_group_set_ports(smi, 0, RTL8367S_PORTS_ALL); //初始化端口led
+
+        	  err = rtl8367S_led_group_set_mode(smi, 0);			//设置模式为0
+		  /*set  	led0    led1   led2
+		  mode 0	00   0010  0011  0100
+		  mode 1	01   0110  0111  1000
+		  mode 2	10   0001  0110  1001
+		  mode 3	11   1000  0110  0111*/
+        	  err = rtl8367S_led_op_select_parallel(smi);
+		  //1:scan mode 1471, 2:parallel mode 1472, 3:mdx mode (serial mode) 14F7
+
+        	  err = rtl8367S_led_blinkrate_set(smi, 1);
+		  //blinkRate | Support 6 blink rates LED blink rate at 43ms, 84ms, 120ms, 170ms, 340ms and 670ms
+		  //43ms 0,84ms 1 ,120ms 2,170ms 3, 340ms 4,670ms 5
+
+        	  err = rtl8367S_led_group_set_config(smi, 0, 2);
+		  //set led0 mode 2
+		  err = rtl8367S_led_group_set_config(smi, 1, 2);
+		  //set led1 mode 2
+		  err = rtl8367S_led_group_set_config(smi, 2, 2);
+		  //set led2 mode 
+		  /*  0000        LED_Off                
+		      0001        Dup/Col                
+		      0010        Link/Act               
+		      0011        Spd1000                
+		      0100        Spd100                 
+		      0101        Spd10                  
+	  	      0110        Spd1000/Act            
+		      0111        Spd100/Act             
+		      1000        Spd10/Act              
+		      1001        Spd100 (10)/Act        
+		      1010        Fiber                  
+		      1011        Fault                  
+		      1100        Link/Rx                
+		      1101        Link/Tx                
+		      1110        Master                 
+		      1111        Act                    
+		 */
+		}	  
+
 	} else {
 		err = rtl8367b_extif_init(smi, 0, pdata->extif0_cfg);
 		if (err)
@@ -899,6 +1373,14 @@ static int rtl8367b_setup(struct rtl8366_smi *smi)
 			RTL8367B_PORT_MISC_CFG_EGRESS_MODE_ORIGINAL <<
 				RTL8367B_PORT_MISC_CFG_EGRESS_MODE_SHIFT);
 
+	for (i = 0; i < 5; i++) {
+	    int data;
+            rtl8367b_read_phy_reg(smi, i, 0, &data);
+            data &= 0xF7FF;
+            data |= 0x200;
+            rtl8367b_write_phy_reg(smi, i, 0, data);
+	}
+
 	return 0;
 }
 
@@ -1229,12 +1711,15 @@ static int rtl8367b_sw_get_port_link(struct switch_dev *dev,
 				    struct switch_port_link *link)
 {
 	struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
-	u32 data = 0;
+	u32 data = 0, sds_misc = 0;
 	u32 speed;
 
 	if (port >= RTL8367B_NUM_PORTS)
 		return -EINVAL;
 
+	if(port == 6 && of_device_is_compatible(smi->parent->of_node, "realtek,rtl8367s"))
+		rtl8366_smi_read_reg(smi, RTL8367S_SDS_MISC, &sds_misc);
+
 	if (smi->rtl8367b_chip >= RTL8367B_CHIP_RTL8367S_VB) /* Family D */
 		rtl8366_smi_read_reg(smi, RTL8367D_PORT_STATUS_REG(port), &data);
 	else
@@ -1254,6 +1739,7 @@ static int rtl8367b_sw_get_port_link(struct switch_dev *dev,
 	else
 		speed = (data & RTL8367B_PORT_STATUS_SPEED_MASK);
 	switch (speed) {
+
 	case RTL8367B_PORT_STATUS_SPEED_10:
 		link->speed = SWITCH_PORT_SPEED_10;
 		break;
@@ -1261,7 +1747,7 @@ static int rtl8367b_sw_get_port_link(struct switch_dev *dev,
 		link->speed = SWITCH_PORT_SPEED_100;
 		break;
 	case RTL8367B_PORT_STATUS_SPEED_1000:
-		link->speed = SWITCH_PORT_SPEED_1000;
+		link->speed = (((sds_misc & RTL8367S_CFG_MAC8_SEL_HSGMII_MASK)>> RTL8367S_CFG_MAC8_SEL_HSGMII_SHIFT) == 1)? SWITCH_PORT_SPEED_2500: SWITCH_PORT_SPEED_1000;
 		break;
 	default:
 		link->speed = SWITCH_PORT_SPEED_UNKNOWN;
@@ -1574,7 +2060,7 @@ static int  rtl8367b_probe(struct platform_device *pdev)
 	smi->cmd_write = 0xb8;
 	smi->ops = &rtl8367b_smi_ops;
 	smi->num_ports = RTL8367B_NUM_PORTS;
-	smi->cpu_port = UINT_MAX; /* not defined yet */
+	smi->cpu_port = UINT_MAX;
 	smi->num_vlan_mc = RTL8367B_NUM_VLANS;
 	smi->mib_counters = rtl8367b_mib_counters;
 	smi->num_mib_counters = ARRAY_SIZE(rtl8367b_mib_counters);
@@ -1584,7 +2070,7 @@ static int  rtl8367b_probe(struct platform_device *pdev)
 		goto err_free_smi;
 
 	platform_set_drvdata(pdev, smi);
-
+	
 	err = rtl8367b_switch_init(smi);
 	if (err)
 		goto err_clear_drvdata;
@@ -1601,11 +2087,7 @@ static int  rtl8367b_probe(struct platform_device *pdev)
 	return err;
 }
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(6,11,0)
 static int rtl8367b_remove(struct platform_device *pdev)
-#else
-static void rtl8367b_remove(struct platform_device *pdev)
-#endif
 {
 	struct rtl8366_smi *smi = platform_get_drvdata(pdev);
 
@@ -1616,9 +2098,7 @@ static void rtl8367b_remove(struct platform_device *pdev)
 		kfree(smi);
 	}
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(6,11,0)
 	return 0;
-#endif
 }
 
 static void rtl8367b_shutdown(struct platform_device *pdev)
@@ -1632,6 +2112,7 @@ static void rtl8367b_shutdown(struct platform_device *pdev)
 #ifdef CONFIG_OF
 static const struct of_device_id rtl8367b_match[] = {
 	{ .compatible = "realtek,rtl8367b" },
+	{ .compatible = "realtek,rtl8367s" },
 	{},
 };
 MODULE_DEVICE_TABLE(of, rtl8367b_match);
@@ -1640,7 +2121,6 @@ MODULE_DEVICE_TABLE(of, rtl8367b_match);
 static struct platform_driver rtl8367b_driver = {
 	.driver = {
 		.name		= RTL8367B_DRIVER_NAME,
-		.owner		= THIS_MODULE,
 #ifdef CONFIG_OF
 		.of_match_table = of_match_ptr(rtl8367b_match),
 #endif
diff --git a/drivers/net/phy/swconfig.c b/drivers/net/phy/swconfig.c
index 1e23b8785..10dc8d060 100644
--- a/drivers/net/phy/swconfig.c
+++ b/drivers/net/phy/swconfig.c
@@ -24,7 +24,6 @@
 #include <linux/skbuff.h>
 #include <linux/switch.h>
 #include <linux/of.h>
-#include <linux/version.h>
 #include <uapi/linux/mii.h>
 
 #define SWCONFIG_DEVNAME	"switch%d"
@@ -1054,13 +1053,11 @@ static struct genl_family switch_fam = {
 	.module = THIS_MODULE,
 	.ops = swconfig_ops,
 	.n_ops = ARRAY_SIZE(swconfig_ops),
-#if LINUX_VERSION_CODE > KERNEL_VERSION(6,0,0)
 	.resv_start_op = SWITCH_CMD_SET_VLAN + 1,
-#endif
 };
 
 #ifdef CONFIG_OF
-static void
+void
 of_switch_load_portmap(struct switch_dev *dev)
 {
 	struct device_node *port;
diff --git a/drivers/net/phy/swconfig_leds.c b/drivers/net/phy/swconfig_leds.c
index 1d309c046..1fcd4432b 100644
--- a/drivers/net/phy/swconfig_leds.c
+++ b/drivers/net/phy/swconfig_leds.c
@@ -85,11 +85,7 @@ swconfig_trig_update_port_mask(struct led_trigger *trigger)
 	sw_trig = (void *) trigger;
 
 	port_mask = 0;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,16,0)
 	spin_lock(&trigger->leddev_list_lock);
-#else
-	read_lock(&trigger->leddev_list_lock);
-#endif
 	list_for_each(entry, &trigger->led_cdevs) {
 		struct led_classdev *led_cdev;
 		struct swconfig_trig_data *trig_data;
@@ -102,11 +98,7 @@ swconfig_trig_update_port_mask(struct led_trigger *trigger)
 			read_unlock(&trig_data->lock);
 		}
 	}
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,16,0)
 	spin_unlock(&trigger->leddev_list_lock);
-#else
-	read_unlock(&trigger->leddev_list_lock);
-#endif
 
 	sw_trig->port_mask = port_mask;
 
@@ -426,22 +418,14 @@ swconfig_trig_update_leds(struct switch_led_trigger *sw_trig)
 	struct led_trigger *trigger;
 
 	trigger = &sw_trig->trig;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,16,0)
 	spin_lock(&trigger->leddev_list_lock);
-#else
-	read_lock(&trigger->leddev_list_lock);
-#endif
 	list_for_each(entry, &trigger->led_cdevs) {
 		struct led_classdev *led_cdev;
 
 		led_cdev = list_entry(entry, struct led_classdev, trig_list);
 		swconfig_trig_led_event(sw_trig, led_cdev);
 	}
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,16,0)
 	spin_unlock(&trigger->leddev_list_lock);
-#else
-	read_unlock(&trigger->leddev_list_lock);
-#endif
 }
 
 static void
