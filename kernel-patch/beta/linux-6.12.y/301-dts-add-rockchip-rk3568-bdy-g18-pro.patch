diff --git a/arch/arm64/boot/dts/rockchip/Makefile b/arch/arm64/boot/dts/rockchip/Makefile
index ca9e04c88..56589b742 100644
--- a/arch/arm64/boot/dts/rockchip/Makefile
+++ b/arch/arm64/boot/dts/rockchip/Makefile
@@ -164,6 +164,7 @@ dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3568-dg-tn3568.dtb
 dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3568-alark35-3500.dtb
 dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3568-ec-x.dtb
 dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3568-evb1-v10.dtb
+dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3568-bdy-g18-pro.dtb
 dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3568-fastrhino-r66s.dtb
 dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3568-fastrhino-r68s.dtb
 dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3568-hinlink-h66k.dtb
diff --git a/drivers/net/phy/rtl8367b.c b/drivers/net/phy/rtl8367b.c
index 497bd08c8..3524cecf6 100644
--- a/drivers/net/phy/rtl8367b.c
+++ b/drivers/net/phy/rtl8367b.c
@@ -19,7 +19,6 @@
 #include <linux/delay.h>
 #include <linux/skbuff.h>
 #include <linux/rtl8367.h>
-#include <linux/version.h>
 
 #include "rtl8366_smi.h"
 
@@ -215,6 +214,95 @@
 
 #define RTL8367B_RTL_MAGIC_ID_REG		0x13c2
 #define   RTL8367B_RTL_MAGIC_ID_VAL		0x0249
+//---------------------RTL8367S---------------------------------------
+#define RTL8367S_EXT_TXC_DLY_REG		0x13f9
+#define   RTL8367S_EXT1_GMII_TX_DELAY_SHIFT	12
+#define   RTL8367S_EXT0_GMII_TX_DELAY_SHIFT	9
+#define   RTL8367S_EXT_GMII_TX_DELAY_MASK	GENMASK(2,0)
+
+#define RTL8367S_SDS_MISC			0x1d11
+#define   RTL8367S_CFG_SGMII_RXFC		BIT(14)
+#define   RTL8367S_CFG_SGMII_TXFC		BIT(13)
+#define   RTL8367S_CFG_MAC8_SEL_HSGMII_SHIFT	11
+#define   RTL8367S_CFG_MAC8_SEL_HSGMII_MASK	BIT(11)
+#define   RTL8367S_CFG_SGMII_FDUP		BIT(10)
+#define   RTL8367S_CFG_SGMII_LINK		BIT(9)
+#define   RTL8367S_CFG_SGMII_SPD_SHIFT		7
+#define   RTL8367S_CFG_SGMII_SPD_MASK		GENMASK(8,7)
+#define   RTL8367S_CFG_MAC8_SEL_SGMII		BIT(6)
+
+#define RTL8367S_SDS_INDACS_CMD_REG            0x6600
+#define   RTL8367S_SDS_CMD                       BIT(7)
+#define   RTL8367S_SDS_RWOP                      BIT(6)
+#define RTL8367S_SDS_INDACS_ADDR_REG           0x6601
+#define RTL8367S_SDS_INDACS_DATA_REG           0x6602
+#define RTL8367S_CPU_PORT_NUM       6
+
+//led 
+#define    RTL8367S_REG_LED_ACTIVE_LOW_CFG0    0x1b0e
+#define    RTL8367S_LED_ACTIVE_LOW_CFG0_DUMMY_15_OFFSET    15
+#define    RTL8367S_LED_ACTIVE_LOW_CFG0_DUMMY_15_MASK    0x8000
+#define    RTL8367S_PORT3_LED_ACTIVE_LOW_OFFSET    12
+#define    RTL8367S_PORT3_LED_ACTIVE_LOW_MASK    0x7000
+#define    RTL8367S_LED_ACTIVE_LOW_CFG0_DUMMY_11_OFFSET    11
+#define    RTL8367S_LED_ACTIVE_LOW_CFG0_DUMMY_11_MASK    0x800
+#define    RTL8367S_PORT2_LED_ACTIVE_LOW_OFFSET    8
+#define    RTL8367S_PORT2_LED_ACTIVE_LOW_MASK    0x700
+#define    RTL8367S_DUMMY_7_OFFSET    7
+#define    RTL8367S_DUMMY_7_MASK    0x80
+#define    RTL8367S_PORT1_LED_ACTIVE_LOW_OFFSET    4
+#define    RTL8367S_PORT1_LED_ACTIVE_LOW_MASK    0x70
+#define    RTL8367S_DUMMY_3_OFFSET    3
+#define    RTL8367S_DUMMY_3_MASK    0x8
+#define    RTL8367S_PORT0_LED_ACTIVE_LOW_OFFSET    0
+#define    RTL8367S_PORT0_LED_ACTIVE_LOW_MASK    0x7
+
+#define    RTL8367S_REG_LED_ACTIVE_LOW_CFG1    0x1b0f
+#define    RTL8367S_LED_ACTIVE_LOW_CFG1_DUMMY_15_OFFSET    15
+#define    RTL8367S_LED_ACTIVE_LOW_CFG1_DUMMY_15_MASK    0x8000
+#define    RTL8367S_PORT7_LED_ACTIVE_LOW_OFFSET    12
+#define    RTL8367S_PORT7_LED_ACTIVE_LOW_MASK    0x7000
+#define    RTL8367S_LED_ACTIVE_LOW_CFG1_DUMMY_11_OFFSET    11
+#define    RTL8367S_LED_ACTIVE_LOW_CFG1_DUMMY_11_MASK    0x800
+#define    RTL8367S_PORT6_LED_ACTIVE_LOW_OFFSET    8
+#define    RTL8367S_PORT6_LED_ACTIVE_LOW_MASK    0x700
+#define    RTL8367S_DUMMY_1b0f_b_OFFSET    7
+#define    RTL8367S_DUMMY_1b0f_b_MASK    0x80
+#define    RTL8367S_PORT5_LED_ACTIVE_LOW_OFFSET    4
+#define    RTL8367S_PORT5_LED_ACTIVE_LOW_MASK    0x70
+#define    RTL8367S_DUMMY_1b0f_a_OFFSET    3
+#define    RTL8367S_DUMMY_1b0f_a_MASK    0x8
+#define    RTL8367S_PORT4_LED_ACTIVE_LOW_OFFSET    0
+#define    RTL8367S_PORT4_LED_ACTIVE_LOW_MASK    0x7
+
+#define    RTL8367S_REG_LED_ACTIVE_LOW_CFG2    0x1b10
+#define    RTL8367S_DUMMY_1b10_b_OFFSET    7
+#define    RTL8367S_DUMMY_1b10_b_MASK    0xFF80
+#define    RTL8367S_PORT9_LED_ACTIVE_LOW_OFFSET    4
+#define    RTL8367S_PORT9_LED_ACTIVE_LOW_MASK    0x70
+#define    RTL8367S_DUMMY_1b10_a_OFFSET    3
+#define    RTL8367S_DUMMY_1b10_a_MASK    0x8
+#define    RTL8367S_PORT8_LED_ACTIVE_LOW_OFFSET    0
+#define    RTL8367S_PORT8_LED_ACTIVE_LOW_MASK    0x7
+
+#define RTL8367S_PORT_0                  BIT(0)
+#define RTL8367S_PORT_1                  BIT(1)
+#define RTL8367S_PORT_2                  BIT(2)
+#define RTL8367S_PORT_3                  BIT(3)
+#define RTL8367S_PORT_4                  BIT(4)
+#define RTL8367S_PORT_5                  BIT(5)
+#define RTL8367S_PORT_6                  BIT(6)
+#define RTL8367S_PORT_7                  BIT(7)
+#define RTL8367S_PORT_E1                 BIT(8)  /* external port 1 */
+#define RTL8367S_PORT_E0                 BIT(9)  /* external port 0 */
+
+#define RTL8367S_PORTS_ALL                                       \
+        (RTL8367S_PORT_0 | RTL8367S_PORT_1 | RTL8367S_PORT_2 |     \
+         RTL8367S_PORT_3 | RTL8367S_PORT_4 | RTL8367S_PORT_5 |     \
+         RTL8367S_PORT_6 | RTL8367S_PORT_7 | RTL8367S_PORT_E1 |    \
+         RTL8367S_PORT_E0)
+//-------------------RTL8367S--------------------------------------
+
 
 #define RTL8367B_IA_CTRL_REG			0x1f00
 #define   RTL8367B_IA_CTRL_RW(_x)		((_x) << 1)
@@ -385,6 +473,34 @@ rtl8367b_mib_counters[RTL8367B_NUM_MIB_COUNTERS] = {
 			return err;					\
 	} while (0)
 
+#define REG_RWBTS(_smi, _reg, _bits, _val)				\
+	do {								\
+		err = rtl8366_smi_rwbts(_smi, _reg, _bits, _val);	\
+		if (err)						\
+			return err; 				\
+	} while (0)
+
+#define REG_RWBT(_smi, _reg, _bit, _val)				\
+	do {								\
+		err = rtl8366_smi_rwbt(_smi, _reg, _bit, _val);	\
+		if (err)						\
+			return err; 				\
+	} while (0)
+
+#define REG_RDBT(_smi, _reg, _bit, _val)				\
+	do {								\
+		err = rtl8366_smi_rdbt(_smi, _reg, _bit, _val);	\
+		if (err)						\
+			return err; 				\
+	} while (0)
+
+#define REG_RDBTS(_smi, _reg, _bits, _val)				\
+	do {								\
+		err = rtl8366_smi_rdbts(_smi, _reg, _bits, _val);	\
+		if (err)						\
+			return err; 				\
+	} while (0)
+
 static const struct rtl8367b_initval rtl8367b_initvals[] = {
 	{0x1B03, 0x0876}, {0x1200, 0x7FC4}, {0x1305, 0xC000}, {0x121E, 0x03CA},
 	{0x1233, 0x0352}, {0x1234, 0x0064}, {0x1237, 0x0096}, {0x1238, 0x0078},
@@ -605,7 +721,119 @@ static int rtl8367b_extif_set_mode(struct rtl8366_smi *smi, int id,
 				   enum rtl8367_extif_mode mode)
 {
 	int err;
-	u32 data;
+	u32 data,option,regValue;
+
+	int i;
+	/* for SGMII, works (from rtl8367s_api.c in TL-R600VPN v4 GPL) */
+	unsigned int redData[][2] = {
+		{0x04D7, 0x0480},
+		{0xF994, 0x0481},
+		{0x21A2, 0x0482},
+		{0x6960, 0x0483},
+		{0x9728, 0x0484},
+		{0x9D85, 0x0423},
+		{0xD810, 0x0424},
+		{0x83F2, 0x002E}
+	};
+
+	unsigned int redDataSB[][2] = { 
+		{0x04D7, 0x0480}, 
+		{0xF994, 0x0481}, 
+		{0x2420, 0x0482}, 
+		{0x6960, 0x0483}, 
+		{0x9728, 0x0484}, 
+		{0x9D85, 0x0423}, 
+		{0xD810, 0x0424}, 
+		{0x83F2, 0x002E} 
+	};
+
+	unsigned int redDataH[][2] = {
+		{0x7180, 0x2},
+		{0x82F0, 0x0500},
+		{0xF195, 0x0501},
+		{0x31A2, 0x0502},
+		{0x7960, 0x0503},
+		{0x9728, 0x0504},
+		{0x9D85, 0x0423},
+		{0xD810, 0x0424},
+		{0x0F80, 0x0001},
+		{0x83F2, 0x002E}
+	};
+
+	unsigned int redData1[][2] =  { 
+		{0x82F1, 0x0500}, 
+		{0xF195, 0x0501}, 
+		{0x31A2, 0x0502}, 
+		{0x796C, 0x0503}, 
+		{0x9728, 0x0504}, 
+		{0x9D85, 0x0423}, 
+		{0xD810, 0x0424}, 
+		{0x0F80, 0x0001}, 
+		{0x83F2, 0x002E} 
+	};
+	unsigned int redData5[][2] =  { 
+		{0x82F1, 0x0500}, 
+		{0xF195, 0x0501}, 
+		{0x31A2, 0x0502}, 
+		{0x796C, 0x0503}, 
+		{0x9728, 0x0504}, 
+		{0x9D85, 0x0423}, 
+		{0xD810, 0x0424}, 
+		{0x0F80, 0x0001}, 
+		{0x83F2, 0x002E} 
+	};
+	unsigned int redData6[][2] =  { 
+		{0x82F1, 0x0500}, 
+		{0xF195, 0x0501}, 
+		{0x31A2, 0x0502}, 
+		{0x796C, 0x0503}, 
+		{0x9728, 0x0504}, 
+		{0x9D85, 0x0423}, 
+		{0xD810, 0x0424}, 
+		{0x0F80, 0x0001}, 
+		{0x83F2, 0x002E} 
+	};
+	unsigned int redData8[][2] =  { 
+		{0x82F1, 0x0500}, 
+		{0xF995, 0x0501}, 
+		{0x31A2, 0x0502}, 
+		{0x796C, 0x0503}, 
+		{0x9728, 0x0504}, 
+		{0x9D85, 0x0423}, 
+		{0xD810, 0x0424}, 
+		{0x0F80, 0x0001}, 
+		{0x83F2, 0x002E} 
+	};
+	unsigned int redData9[][2] =  { 
+		{0x82F1, 0x0500}, 
+		{0xF995, 0x0501}, 
+		{0x31A2, 0x0502}, 
+		{0x796C, 0x0503}, 
+		{0x9728, 0x0504}, 
+		{0x9D85, 0x0423}, 
+		{0xD810, 0x0424}, 
+		{0x0F80, 0x0001}, 
+		{0x83F2, 0x002E} 
+	};
+	unsigned int redDataHB[][2] = { 
+		{0x82F0, 0x0500}, 
+		{0xF195, 0x0501}, 
+		{0x31A2, 0x0502}, 
+		{0x7960, 0x0503}, 
+		{0x9728, 0x0504}, 
+		{0x9D85, 0x0423}, 
+		{0xD810, 0x0424}, 
+		{0x0F80, 0x0001}, 
+		{0x83F2, 0x002E} 
+	};
+
+	if ((mode == RTL8367S_EXTIF_MODE_SGMII ||
+	     mode == RTL8367S_EXTIF_MODE_HSGMII)
+	     && id != RTL8367_EXTIF1) {
+		dev_err(smi->parent,
+			"SGMII/HSGMII mode is only available in extif1\n");
+		return -EINVAL;
+	}
 
 	/* set port mode */
 	switch (mode) {
@@ -658,6 +886,16 @@ static int rtl8367b_extif_set_mode(struct rtl8366_smi *smi, int id,
 			RTL8367B_DEBUG0_SEL33(id),
 			RTL8367B_DEBUG0_SEL33(id));
 		REG_RMW(smi, RTL8367B_EXT_RGMXF_REG(id), BIT(6), BIT(6));
+		if (of_device_is_compatible(smi->parent->of_node,
+                                   "realtek,rtl8367s")) {
+	        REG_RMW(smi, RTL8367S_EXT_TXC_DLY_REG,
+	        RTL8367S_EXT_GMII_TX_DELAY_MASK
+	                << RTL8367S_EXT1_GMII_TX_DELAY_SHIFT |
+	        RTL8367S_EXT_GMII_TX_DELAY_MASK
+	                << RTL8367S_EXT0_GMII_TX_DELAY_SHIFT,
+	        5 << RTL8367S_EXT1_GMII_TX_DELAY_SHIFT |        /* shoud be configured */
+	        6 << RTL8367S_EXT0_GMII_TX_DELAY_SHIFT);        /* in set_rgmii_delay? */
+		}
 		break;
 
 	case RTL8367_EXTIF_MODE_MII_MAC:
@@ -666,11 +904,111 @@ static int rtl8367b_extif_set_mode(struct rtl8366_smi *smi, int id,
 		REG_RMW(smi, RTL8367B_BYPASS_LINE_RATE_REG, BIT(id), 0);
 		REG_RMW(smi, RTL8367B_EXT_RGMXF_REG(id), BIT(6), 0);
 		break;
+	case RTL8367S_EXTIF_MODE_SGMII:
+	     REG_WR(smi, 0x13C0, 0x0249);
+	     REG_RD(smi, 0x13C1, &option);
+             REG_WR(smi, 0x13C0, 0x0000);   
+	    if (!of_device_is_compatible(smi->parent->of_node,
+	                                 "realtek,rtl8367s"))
+	            goto invalid_mode;
+
+            if(option == 0)
+            {
+		/* setup SerDes register for SGMII */
+                for(i = 0; i <= 7; i++)
+                {
+			REG_WR(smi, RTL8367S_SDS_INDACS_DATA_REG, redData[i][0]);
+			REG_WR(smi, RTL8367S_SDS_INDACS_ADDR_REG, redData[i][1]);
+			REG_WR(smi, RTL8367S_SDS_INDACS_CMD_REG, 0x00C0);
+                }
+            }
+            else
+            {
+                for(i = 0; i <= 7; i++)
+                {
+			REG_WR(smi, RTL8367S_SDS_INDACS_DATA_REG, redDataSB[i][0]);
+			REG_WR(smi, RTL8367S_SDS_INDACS_ADDR_REG, redDataSB[i][1]);
+			REG_WR(smi, RTL8367S_SDS_INDACS_CMD_REG, 0x00C0);
+                }
+            }
+	    break;
+
+	case RTL8367S_EXTIF_MODE_HSGMII:
+	     REG_WR(smi, 0x13c2, 0x0249);
+	     REG_RD(smi, 0x1301, &regValue);
+	     REG_WR(smi, 0x13c2, 0x0000);
+	    if (!of_device_is_compatible(smi->parent->of_node,
+	                                 "realtek,rtl8367s"))
+	            goto invalid_mode;
+	    if ( ((regValue & 0x00F0) >> 4) == 0x0001)
+            {
+		    /* setup SerDes register for HSGMII */
+                    for(i = 0; i <= 8; i++)
+                    {
+			    REG_WR(smi, RTL8367S_SDS_INDACS_DATA_REG, redDataH[i][0]);
+			    REG_WR(smi, RTL8367S_SDS_INDACS_ADDR_REG, redDataH[i][1]);
+			    REG_WR(smi, RTL8367S_SDS_INDACS_CMD_REG, 0x00C0);
+                    }
+            }
+	    else if ( ((regValue & 0x00F0) >> 4) == 0x0005)
+	    {
+                    for(i = 0; i <= 8; i++)
+                    {
+                            REG_WR(smi, RTL8367S_SDS_INDACS_DATA_REG, redData5[i][0]);
+                            REG_WR(smi, RTL8367S_SDS_INDACS_ADDR_REG, redData5[i][1]);
+                            REG_WR(smi, RTL8367S_SDS_INDACS_CMD_REG, 0x00C0);
+                    }
+	    }
+            else if ( ((regValue & 0x00F0) >> 4) == 0x0006)
+            {
+                    for(i = 0; i <= 8; i++)
+                    {
+                            REG_WR(smi, RTL8367S_SDS_INDACS_DATA_REG, redData6[i][0]);
+                            REG_WR(smi, RTL8367S_SDS_INDACS_ADDR_REG, redData6[i][1]);
+                            REG_WR(smi, RTL8367S_SDS_INDACS_CMD_REG, 0x00C0);
+                    }
+            }
+            else if ( ((regValue & 0x00F0) >> 4) == 0x0008)
+            {
+                    for(i = 0; i <= 8; i++)
+                    {
+                            REG_WR(smi, RTL8367S_SDS_INDACS_DATA_REG, redData8[i][0]);
+                            REG_WR(smi, RTL8367S_SDS_INDACS_ADDR_REG, redData8[i][1]);
+                            REG_WR(smi, RTL8367S_SDS_INDACS_CMD_REG, 0x00C0);
+                    }
+            }
+            else if ( ((regValue & 0x00F0) >> 4) == 0x0009)
+            {
+                    for(i = 0; i <= 8; i++)
+                    {
+                            REG_WR(smi, RTL8367S_SDS_INDACS_DATA_REG, redData9[i][0]);
+                            REG_WR(smi, RTL8367S_SDS_INDACS_ADDR_REG, redData9[i][1]);
+                            REG_WR(smi, RTL8367S_SDS_INDACS_CMD_REG, 0x00C0);
+                    }
+            }
+	    else {
+                    for(i = 0; i <= 8; i++)
+                    {
+                            REG_WR(smi, RTL8367S_SDS_INDACS_DATA_REG, redDataHB[i][0]);
+                            REG_WR(smi, RTL8367S_SDS_INDACS_ADDR_REG, redDataHB[i][1]);
+                            REG_WR(smi, RTL8367S_SDS_INDACS_CMD_REG, 0x00C0);
+                    }
+	    }
+    	    break;
 
 	default:
-		dev_err(smi->parent,
-			"invalid mode for external interface %d\n", id);
-		return -EINVAL;
+		goto invalid_mode;
+	}
+
+	if (id == RTL8367_EXTIF1 &&
+        of_device_is_compatible(smi->parent->of_node, "realtek,rtl8367s")) {
+            REG_RMW(smi, RTL8367S_SDS_MISC, RTL8367S_CFG_MAC8_SEL_HSGMII_MASK,
+                    (mode == RTL8367S_EXTIF_MODE_HSGMII)
+                            ? RTL8367S_CFG_MAC8_SEL_HSGMII_MASK : 0);
+            REG_RMW(smi, RTL8367S_SDS_MISC, RTL8367S_CFG_MAC8_SEL_SGMII,
+                    (mode == RTL8367S_EXTIF_MODE_SGMII)
+                            ? RTL8367S_CFG_MAC8_SEL_SGMII : 0);
+
 	}
 
 	if (id <= 1)
@@ -682,7 +1020,17 @@ static int rtl8367b_extif_set_mode(struct rtl8366_smi *smi, int id,
 			RTL8367B_DIS2_RGMII_MASK << RTL8367B_DIS2_RGMII_SHIFT,
 			mode << RTL8367B_DIS2_RGMII_SHIFT);
 
+	if (mode == RTL8367S_EXTIF_MODE_SGMII ||  mode == RTL8367S_EXTIF_MODE_HSGMII) {
+            REG_WR(smi, RTL8367S_SDS_INDACS_DATA_REG, 0x7106);
+            REG_WR(smi, RTL8367S_SDS_INDACS_ADDR_REG, 0x0003);
+            REG_WR(smi, RTL8367S_SDS_INDACS_CMD_REG, 0x00C0);
+        }
 	return 0;
+
+invalid_mode:
+		dev_err(smi->parent,
+			"invalid mode for external interface %d\n", id);
+		return -EINVAL;
 }
 
 static int rtl8367b_extif_set_force(struct rtl8366_smi *smi, int id,
@@ -699,6 +1047,20 @@ static int rtl8367b_extif_set_force(struct rtl8366_smi *smi, int id,
 	val |= pa->link ? RTL8367B_DI_FORCE_LINK : 0;
 	val |= pa->duplex ? RTL8367B_DI_FORCE_DUPLEX : 0;
 
+	if (id == RTL8367_EXTIF1 &&
+            of_device_is_compatible(smi->parent->of_node, "realtek,rtl8367s")) {
+            REG_RMW(smi, RTL8367S_SDS_MISC, RTL8367S_CFG_SGMII_FDUP,
+                    pa->duplex ? RTL8367S_CFG_SGMII_FDUP : 0);
+            REG_RMW(smi, RTL8367S_SDS_MISC, RTL8367S_CFG_SGMII_SPD_MASK,
+                    pa->speed << RTL8367S_CFG_SGMII_SPD_SHIFT);
+            REG_RMW(smi, RTL8367S_SDS_MISC, RTL8367S_CFG_SGMII_LINK,
+                    pa->link ? RTL8367S_CFG_SGMII_LINK : 0);
+            REG_RMW(smi, RTL8367S_SDS_MISC, RTL8367S_CFG_SGMII_TXFC,
+                    pa->txpause ? RTL8367S_CFG_SGMII_TXFC : 0);
+            REG_RMW(smi, RTL8367S_SDS_MISC, RTL8367S_CFG_SGMII_RXFC,
+                    pa->rxpause ? RTL8367S_CFG_SGMII_RXFC : 0);
+        }
+
 	if (smi->rtl8367b_chip >= RTL8367B_CHIP_RTL8367S_VB) { /* Family D */
 		val |= (pa->speed << RTL8367D_PORT_STATUS_SPEED1_SHIFT) & RTL8367D_PORT_STATUS_SPEED1_MASK;
 		if (smi->cpu_port != UINT_MAX) {
@@ -752,6 +1114,15 @@ static int rtl8367b_extif_init(struct rtl8366_smi *smi, int id,
 	if (err)
 		return err;
 
+	if (of_device_is_compatible(smi->parent->of_node,
+                                "realtek,rtl8367s")) {
+		    /* disable pre-emphasis */
+		    REG_WR(smi, RTL8367S_SDS_INDACS_DATA_REG, 0x28A0);
+		    REG_WR(smi, RTL8367S_SDS_INDACS_ADDR_REG, 0x0482);
+		    REG_WR(smi, RTL8367S_SDS_INDACS_CMD_REG,
+		           RTL8367S_SDS_CMD | RTL8367S_SDS_RWOP);
+	}
+
 	if (mode != RTL8367_EXTIF_MODE_DISABLED) {
 		err = rtl8367b_extif_set_force(smi, id, &cfg->ability);
 		if (err)
@@ -767,56 +1138,22 @@ static int rtl8367b_extif_init(struct rtl8366_smi *smi, int id,
 }
 
 #ifdef CONFIG_OF
-static int rtl8367b_extif_init_of(struct rtl8366_smi *smi,
+static int rtl8367b_extif_init_of(struct rtl8366_smi *smi,int id,
 				  const char *name)
 {
 	struct rtl8367_extif_config *cfg;
+	enum rtl8367_port_speed speed;
 	const __be32 *prop;
 	int size;
 	int err;
-	unsigned cpu_port;
-	unsigned id = UINT_MAX;
 
 	prop = of_get_property(smi->parent->of_node, name, &size);
-	if (!prop || (size != (10 * sizeof(*prop)))) {
-		dev_err(smi->parent, "%s property is not defined or invalid\n", name);
-		err = -EINVAL;
-		goto err_init;
-	}
+	if (!prop)
+		return rtl8367b_extif_init(smi, id, NULL);
 
-	cpu_port = be32_to_cpup(prop++);
-	switch (cpu_port) {
-	case RTL8367B_CPU_PORT_NUM:
-	case RTL8367B_CPU_PORT_NUM + 1:
-	case RTL8367B_CPU_PORT_NUM + 2:
-		if (smi->rtl8367b_chip == RTL8367B_CHIP_RTL8367R_VB) { /* for the RTL8367R-VB chip, cpu_port 5 corresponds to extif1 */
-			if (cpu_port == RTL8367B_CPU_PORT_NUM)
-				id = 1;
-			else {
-				dev_err(smi->parent, "wrong cpu_port %u in %s property\n", cpu_port, name);
-				err = -EINVAL;
-				goto err_init;
-			}
-		} else if (smi->rtl8367b_chip == RTL8367B_CHIP_RTL8367S_VB) { /* for the RTL8367S-VB chip, cpu_port 7 corresponds to extif1, cpu_port 6 corresponds to extif0 */
-			if (cpu_port != RTL8367B_CPU_PORT_NUM) {
-				id = cpu_port - RTL8367B_CPU_PORT_NUM - 1;
-			} else {
-				dev_err(smi->parent, "wrong cpu_port %u in %s property\n", cpu_port, name);
-				err = -EINVAL;
-				goto err_init;
-			}
-		} else {
-			id = cpu_port - RTL8367B_CPU_PORT_NUM;
-		}
-		if (smi->cpu_port == UINT_MAX) {
-			dev_info(smi->parent, "cpu_port:%u, assigned to extif%u\n", cpu_port, id);
-			smi->cpu_port = cpu_port;
-		}
-		break;
-	default:
-		dev_err(smi->parent, "wrong cpu_port %u in %s property\n", cpu_port, name);
-		err = -EINVAL;
-		goto err_init;
+	if (size != (9 * sizeof(*prop))) {
+		dev_err(smi->parent, "%s property is invalid\n", name);
+		return -EINVAL;
 	}
 
 	cfg = kzalloc(sizeof(struct rtl8367_extif_config), GFP_KERNEL);
@@ -831,26 +1168,100 @@ static int rtl8367b_extif_init_of(struct rtl8366_smi *smi,
 	cfg->ability.rxpause = be32_to_cpup(prop++);
 	cfg->ability.link = be32_to_cpup(prop++);
 	cfg->ability.duplex = be32_to_cpup(prop++);
-	cfg->ability.speed = be32_to_cpup(prop++);
+
+	speed = be32_to_cpup(prop++);
+	if (of_device_is_compatible(smi->parent->of_node, "realtek,rtl8367s") && cfg->mode == RTL8367S_EXTIF_MODE_HSGMII)
+        	speed = RTL8367_PORT_SPEED_1000;
+	cfg->ability.speed = speed;
 
 	err = rtl8367b_extif_init(smi, id, cfg);
 	kfree(cfg);
 
-err_init:
-	if (id != 0) rtl8367b_extif_init(smi, 0, NULL);
-	if (id != 1) rtl8367b_extif_init(smi, 1, NULL);
-	if (id != 2) rtl8367b_extif_init(smi, 2, NULL);
-
 	return err;
 }
 #else
-static int rtl8367b_extif_init_of(struct rtl8366_smi *smi,
+static int rtl8367b_extif_init_of(struct rtl8366_smi *smi,int id,
 				  const char *name)
 {
 	return -EINVAL;
 }
 #endif
 
+/* RTL8367S set led mode */
+static int rtl8367S_led_group_set_ports(struct rtl8366_smi *smi,
+                                       unsigned int group, u16 port_mask)
+{
+        u32 reg;
+        u32 s;
+        int err;
+
+        port_mask &= 0xff;
+        s = (group % 2) * 8;
+        reg = 0x1b24 + (group / 2);
+
+        REG_RMW(smi, reg, (0xff << s), port_mask << s);
+
+        return 0;
+}
+
+static int rtl8367S_led_group_set_mode(struct rtl8366_smi *smi,
+                                      unsigned int mode)
+{
+        u16 mask;
+        u16 set;
+        int err;
+
+        mode &= 0x3;
+
+        mask = (0x3 << 12) | BIT(14);
+        set = (mode << 12) | BIT(14);
+
+        REG_RMW(smi, 0x1b03, mask, set);
+
+        return 0;
+}
+
+static int rtl8367S_led_op_select_parallel(struct rtl8366_smi *smi)
+{
+        int err;
+
+        //REG_WR(smi, 0x1b00, 0x1472);
+	REG_RMW(smi, 0x1b00,BIT(0),0x0); //LEDOP_PARALLEL
+	REG_RMW(smi, 0x1b26, BIT(0),0x0); //Disable serial CLK mode
+	REG_RMW(smi, 0x1b26, BIT(1),0x0); //Disable serial DATA mode
+        return 0;
+}
+
+static int rtl8367S_led_blinkrate_set(struct rtl8366_smi *smi, unsigned int rate)
+{
+        u16 mask;
+        u16 set;
+        int err;
+
+        mask = 0x7 << 1;
+        set = (rate & 0x7) << 1;
+        REG_RMW(smi, 0x1b02, mask, set);
+
+        return 0;
+}
+
+
+static int rtl8367S_led_group_set_config(struct rtl8366_smi *smi,
+                                        unsigned int led, unsigned int cfg)
+{
+        u16 mask;
+        u16 set;
+        int err;
+
+        mask = (0xf << (led * 4)) | BIT(14);
+        set = (cfg & 0xf) << (led * 4);
+
+        REG_RMW(smi, 0x1b03, mask, set);
+        return 0;
+}
+
+/* RTL8367S set led mode */
+
 static int rtl8367b_setup(struct rtl8366_smi *smi)
 {
 	struct rtl8367_platform_data *pdata;
@@ -865,9 +1276,72 @@ static int rtl8367b_setup(struct rtl8366_smi *smi)
 
 	/* initialize external interfaces */
 	if (smi->parent->of_node) {
-		err = rtl8367b_extif_init_of(smi, "realtek,extif");
+		err = rtl8367b_extif_init_of(smi, 0,"realtek,extif0"); //port 5
+		if (err)
+			return err;
+
+		err = rtl8367b_extif_init_of(smi, 1, "realtek,extif1"); //port 6
 		if (err)
 			return err;
+
+		err = rtl8367b_extif_init_of(smi, 2, "realtek,extif2"); //port 7
+		if (err)
+			return err;
+	
+		if (of_device_is_compatible(smi->parent->of_node, "realtek,rtl8367s"))
+		{
+		//高低点平接反了需要设置
+		  /*u32 regValue;
+		  REG_RD(smi,RTL8367S_REG_LED_ACTIVE_LOW_CFG0, &regValue);
+		  dev_info(smi->parent, "CFG0 is %04x\n",regValue);
+		  regValue &= ~(RTL8367S_PORT0_LED_ACTIVE_LOW_MASK | RTL8367S_PORT1_LED_ACTIVE_LOW_MASK | 
+				RTL8367S_PORT2_LED_ACTIVE_LOW_MASK | RTL8367S_PORT3_LED_ACTIVE_LOW_MASK);
+		  REG_WR(smi, RTL8367S_REG_LED_ACTIVE_LOW_CFG0, regValue);
+		  REG_RD(smi, RTL8367S_REG_LED_ACTIVE_LOW_CFG0, &regValue);
+		  dev_info(smi->parent, "Updated CFG0: 0x%04x\n", regValue);*/
+
+
+        	  /* setup LEDs */
+      		  err = rtl8367S_led_group_set_ports(smi, 0, RTL8367S_PORTS_ALL); //初始化端口led
+
+        	  err = rtl8367S_led_group_set_mode(smi, 0);			//设置模式为0
+		  /*set  	led0    led1   led2
+		  mode 0	00   0010  0011  0100
+		  mode 1	01   0110  0111  1000
+		  mode 2	10   0001  0110  1001
+		  mode 3	11   1000  0110  0111*/
+        	  err = rtl8367S_led_op_select_parallel(smi);
+		  //1:scan mode 1471, 2:parallel mode 1472, 3:mdx mode (serial mode) 14F7
+
+        	  err = rtl8367S_led_blinkrate_set(smi, 1);
+		  //blinkRate | Support 6 blink rates LED blink rate at 43ms, 84ms, 120ms, 170ms, 340ms and 670ms
+		  //43ms 0,84ms 1 ,120ms 2,170ms 3, 340ms 4,670ms 5
+
+        	  err = rtl8367S_led_group_set_config(smi, 0, 2);
+		  //set led0 mode 2
+		  err = rtl8367S_led_group_set_config(smi, 1, 2);
+		  //set led1 mode 2
+		  err = rtl8367S_led_group_set_config(smi, 2, 2);
+		  //set led2 mode 
+		  /*  0000        LED_Off                
+		      0001        Dup/Col                
+		      0010        Link/Act               
+		      0011        Spd1000                
+		      0100        Spd100                 
+		      0101        Spd10                  
+	  	      0110        Spd1000/Act            
+		      0111        Spd100/Act             
+		      1000        Spd10/Act              
+		      1001        Spd100 (10)/Act        
+		      1010        Fiber                  
+		      1011        Fault                  
+		      1100        Link/Rx                
+		      1101        Link/Tx                
+		      1110        Master                 
+		      1111        Act                    
+		 */
+		}	  
+
 	} else {
 		err = rtl8367b_extif_init(smi, 0, pdata->extif0_cfg);
 		if (err)
@@ -899,6 +1373,14 @@ static int rtl8367b_setup(struct rtl8366_smi *smi)
 			RTL8367B_PORT_MISC_CFG_EGRESS_MODE_ORIGINAL <<
 				RTL8367B_PORT_MISC_CFG_EGRESS_MODE_SHIFT);
 
+	for (i = 0; i < 5; i++) {
+	    int data;
+            rtl8367b_read_phy_reg(smi, i, 0, &data);
+            data &= 0xF7FF;
+            data |= 0x200;
+            rtl8367b_write_phy_reg(smi, i, 0, data);
+	}
+
 	return 0;
 }
 
@@ -1229,12 +1711,15 @@ static int rtl8367b_sw_get_port_link(struct switch_dev *dev,
 				    struct switch_port_link *link)
 {
 	struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
-	u32 data = 0;
+	u32 data = 0, sds_misc = 0;
 	u32 speed;
 
 	if (port >= RTL8367B_NUM_PORTS)
 		return -EINVAL;
 
+	if(port == 6 && of_device_is_compatible(smi->parent->of_node, "realtek,rtl8367s"))
+		rtl8366_smi_read_reg(smi, RTL8367S_SDS_MISC, &sds_misc);
+
 	if (smi->rtl8367b_chip >= RTL8367B_CHIP_RTL8367S_VB) /* Family D */
 		rtl8366_smi_read_reg(smi, RTL8367D_PORT_STATUS_REG(port), &data);
 	else
@@ -1254,6 +1739,7 @@ static int rtl8367b_sw_get_port_link(struct switch_dev *dev,
 	else
 		speed = (data & RTL8367B_PORT_STATUS_SPEED_MASK);
 	switch (speed) {
+
 	case RTL8367B_PORT_STATUS_SPEED_10:
 		link->speed = SWITCH_PORT_SPEED_10;
 		break;
@@ -1261,7 +1747,7 @@ static int rtl8367b_sw_get_port_link(struct switch_dev *dev,
 		link->speed = SWITCH_PORT_SPEED_100;
 		break;
 	case RTL8367B_PORT_STATUS_SPEED_1000:
-		link->speed = SWITCH_PORT_SPEED_1000;
+		link->speed = (((sds_misc & RTL8367S_CFG_MAC8_SEL_HSGMII_MASK)>> RTL8367S_CFG_MAC8_SEL_HSGMII_SHIFT) == 1)? SWITCH_PORT_SPEED_2500: SWITCH_PORT_SPEED_1000;
 		break;
 	default:
 		link->speed = SWITCH_PORT_SPEED_UNKNOWN;
@@ -1574,7 +2060,7 @@ static int  rtl8367b_probe(struct platform_device *pdev)
 	smi->cmd_write = 0xb8;
 	smi->ops = &rtl8367b_smi_ops;
 	smi->num_ports = RTL8367B_NUM_PORTS;
-	smi->cpu_port = UINT_MAX; /* not defined yet */
+	smi->cpu_port = UINT_MAX;
 	smi->num_vlan_mc = RTL8367B_NUM_VLANS;
 	smi->mib_counters = rtl8367b_mib_counters;
 	smi->num_mib_counters = ARRAY_SIZE(rtl8367b_mib_counters);
@@ -1584,7 +2070,7 @@ static int  rtl8367b_probe(struct platform_device *pdev)
 		goto err_free_smi;
 
 	platform_set_drvdata(pdev, smi);
-
+	
 	err = rtl8367b_switch_init(smi);
 	if (err)
 		goto err_clear_drvdata;
@@ -1601,11 +2087,7 @@ static int  rtl8367b_probe(struct platform_device *pdev)
 	return err;
 }
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(6,11,0)
 static int rtl8367b_remove(struct platform_device *pdev)
-#else
-static void rtl8367b_remove(struct platform_device *pdev)
-#endif
 {
 	struct rtl8366_smi *smi = platform_get_drvdata(pdev);
 
@@ -1616,9 +2098,7 @@ static void rtl8367b_remove(struct platform_device *pdev)
 		kfree(smi);
 	}
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(6,11,0)
 	return 0;
-#endif
 }
 
 static void rtl8367b_shutdown(struct platform_device *pdev)
@@ -1632,6 +2112,7 @@ static void rtl8367b_shutdown(struct platform_device *pdev)
 #ifdef CONFIG_OF
 static const struct of_device_id rtl8367b_match[] = {
 	{ .compatible = "realtek,rtl8367b" },
+	{ .compatible = "realtek,rtl8367s" },
 	{},
 };
 MODULE_DEVICE_TABLE(of, rtl8367b_match);
@@ -1640,7 +2121,6 @@ MODULE_DEVICE_TABLE(of, rtl8367b_match);
 static struct platform_driver rtl8367b_driver = {
 	.driver = {
 		.name		= RTL8367B_DRIVER_NAME,
-		.owner		= THIS_MODULE,
 #ifdef CONFIG_OF
 		.of_match_table = of_match_ptr(rtl8367b_match),
 #endif
diff --git a/drivers/net/phy/swconfig.c b/drivers/net/phy/swconfig.c
index 1e23b8785..10dc8d060 100644
--- a/drivers/net/phy/swconfig.c
+++ b/drivers/net/phy/swconfig.c
@@ -24,7 +24,6 @@
 #include <linux/skbuff.h>
 #include <linux/switch.h>
 #include <linux/of.h>
-#include <linux/version.h>
 #include <uapi/linux/mii.h>
 
 #define SWCONFIG_DEVNAME	"switch%d"
@@ -1054,13 +1053,11 @@ static struct genl_family switch_fam = {
 	.module = THIS_MODULE,
 	.ops = swconfig_ops,
 	.n_ops = ARRAY_SIZE(swconfig_ops),
-#if LINUX_VERSION_CODE > KERNEL_VERSION(6,0,0)
 	.resv_start_op = SWITCH_CMD_SET_VLAN + 1,
-#endif
 };
 
 #ifdef CONFIG_OF
-static void
+void
 of_switch_load_portmap(struct switch_dev *dev)
 {
 	struct device_node *port;
diff --git a/drivers/net/phy/swconfig_leds.c b/drivers/net/phy/swconfig_leds.c
index 1d309c046..1fcd4432b 100644
--- a/drivers/net/phy/swconfig_leds.c
+++ b/drivers/net/phy/swconfig_leds.c
@@ -85,11 +85,7 @@ swconfig_trig_update_port_mask(struct led_trigger *trigger)
 	sw_trig = (void *) trigger;
 
 	port_mask = 0;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,16,0)
 	spin_lock(&trigger->leddev_list_lock);
-#else
-	read_lock(&trigger->leddev_list_lock);
-#endif
 	list_for_each(entry, &trigger->led_cdevs) {
 		struct led_classdev *led_cdev;
 		struct swconfig_trig_data *trig_data;
@@ -102,11 +98,7 @@ swconfig_trig_update_port_mask(struct led_trigger *trigger)
 			read_unlock(&trig_data->lock);
 		}
 	}
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,16,0)
 	spin_unlock(&trigger->leddev_list_lock);
-#else
-	read_unlock(&trigger->leddev_list_lock);
-#endif
 
 	sw_trig->port_mask = port_mask;
 
@@ -426,22 +418,14 @@ swconfig_trig_update_leds(struct switch_led_trigger *sw_trig)
 	struct led_trigger *trigger;
 
 	trigger = &sw_trig->trig;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,16,0)
 	spin_lock(&trigger->leddev_list_lock);
-#else
-	read_lock(&trigger->leddev_list_lock);
-#endif
 	list_for_each(entry, &trigger->led_cdevs) {
 		struct led_classdev *led_cdev;
 
 		led_cdev = list_entry(entry, struct led_classdev, trig_list);
 		swconfig_trig_led_event(sw_trig, led_cdev);
 	}
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,16,0)
 	spin_unlock(&trigger->leddev_list_lock);
-#else
-	read_unlock(&trigger->leddev_list_lock);
-#endif
 }
 
 static void
